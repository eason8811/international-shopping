此前我们已经完成了本跨境电商系统的物流（shipping）领域的请求响应DTO（请求DTO和响应DTO）和基本领域模型（包括领域聚合根，实体，值对象和VO）的实现，现在我们需要根据 @international-shopping.sql 中与物流（shipping）领域相关的库表DDL语句，以及 @international-shopping-shipping-api.yaml 这份物流（shipping）领域的 API 文档，并参考在 `shopping.international.api.req/resp.shipping` 中按照 @international-shopping-shipping-api.yaml 中用到的数据模型编写的用于响应和接受请求的DTO类，以及在`shopping.international.domain.model.aggregate/entity/vo/enums.shipping` 包中编写好的物流（shipping）领域符合DDD的充血模型结构且为领域内的唯一权威逻辑实现的聚合根/实体/值对象/枚举，自顶向下（trigger层的Controller/Job -> domain层的领域服务接口与实现 -> domain层的adapter接口 -> infrastructure层的adapter实现类 -> infrastructure层的Mapper/gateway）实现 API 文档中的接口，并且我有以下要求（如果与 @AGENTS.md 中的要求或说法有冲突，以下面的要求为准）：

1. 命名和位置要求
    - 领域服务接口以 `I**Service` 的命名格式放置在 `shopping.international.domain.service.shipping` 包下
    - 领域服务实现类以 `**Service` 的命名格式放置在 `shopping.international.domain.service.shipping.impl` 包下
    - 领域服务中需要使用的仓储服务（用于访问数据库）的接口以 `I**Repository` 的命名格式放在 `shopping.international.domain.adapter.repository.shipping` 包下
    - 领域服务中需要使用的Port服务（用于访问外部API，在shipping领域中用于提供向17Track API 查询运单状态的功能）的接口以 `I**Port` 的命名格式放在 `shopping.international.domain.adapter.port.shipping` 包下
    - 基础设施（infrastructure层）中的仓储服务实现类以 `**Repository` 的命名格式放置在 `shopping.international.infrastructure.adapter.repository.shipping` 包下
    - 基础设施（infrastructure层）中的Port服务实现类以 `**Port` 的命名格式放置在 `shopping.international.infrastructure.adapter.port.shipping` 包下
    - 基础设施（infrastructure层）中的Mapper接口和PO类以 `**Mapper` 和 `**PO` 的命名格式分别放置在 `shopping.international.infrastructure.dao.shipping` 包和 `shopping.international.infrastructure.dao.shipping.po` 包下，这些Mapper接口和PO类将被基础设施（infrastructure层）中的仓储服务实现类使用
    - 基础设施（infrastructure层）中的gateway API接口和发送请求或接收响应需要用到的DTO以 `**Api` 和 `**Request 或 **Respond` 的命名格式分别放置在 `shopping.international.infrastructure.gateway.shipping` 包和 `shopping.international.infrastructure.gateway.shipping.dto` 包下
    - 基础设施（infrastructure层）中Mapper 接口需要用到的 `**Mapper.xml` 放在`international-shopping-app/src/main/resources/mapper` 目录下
    - 在 `shopping.international.infrastructure.gateway.shipping` 包中声明的 `**Api` 接口应该在 `shopping.international.app.config.RetrofitConfig` @RetrofitConfig 这个 Retrofit 配置类中进行 Bean Create
    - 触发（trigger）层中的Controller类以 `**Controller` 的命名格式放置在 `shopping.international.trigger.controller.shipping` 包下
    - 触发（trigger）层中的定时任务类以 `**Job` 的命名格式放置在 `shopping.international.trigger.job.shipping` 包下
2. 架构要求
    1. domain层中有已实现的符合DDD规则的充血领域模型，包括但不限于 `shopping.international.domain.model.aggregate/entity/vo/enum.shipping` 包中的聚合根/实体/值对象/枚举类，这些充血模型内部都维护了领域不变式，领域服务（`shopping.international.domain.service.shipping.impl` 包下的领域服务实现类）在执行业务逻辑时，应该遵循充血模型中维护领域不变式的实现为领域内唯一权威实现，不应该在其他地方有相似的维护不变式的实现
    2. Controller（trigger层）-- 调用 --> 领域服务（domain层） -- 调用 --> 仓储服务（infrastructure层 `Repository`） -- 调用 --> Mapper方法，或 Controller（trigger层）-- 调用 --> 领域服务（domain层） -- 调用 --> 网关服务（infrastructure层 `Port`） -- 调用 --> Api接口方法
    3. 所有位于 `shopping.international.api.req.shipping` 包中的shipping领域的接口的请求类 `(**Request)` 都已经实现 `shopping.international.types.utils.Verifiable#validate` ，trigger层的 Controller 方法开始时应该首先调用请求对象的 `#validate` 方法进行参数合法性校验（主要是非空，格式，长度，正则等方面的校验），在domain层的领域服务中不再进行这方面校验，校验时应优先使用 `shopping.international.types.utils.FieldValidateUtils` 中的校验方法，如果没有符合要求的校验方法，才允许自行手写校验
    4. 领域服务的方法开始时应首先对入参进行参数合法性校验（只做业务逻辑方面的校验，如唯一，状态合法性等等，**不做**与Controller中重复的非空，格式，长度，正则等方面的校验），并且如果方法签名中有为某个参数添加 `@NotNull` 注解，则不再校验其非空性，校验时应优先使用 `shopping.international.types.utils.FieldValidateUtils` 中的校验方法，如果没有符合要求的校验方法，才允许自行手写校验
    5. 所有与分页相关的接口都使用domain层通用的 @PageQuery.java 和 @PageResult.java
    6. 所有跨领域协作操作下沉到infrastructure层做，保证domain层纯净
    7. 在infrastructure层中不要在for循环内与数据库进行交互，如需批量，应该批量处理后使用批量方法或在 `**Mapper.xml` 中编写SQL
    8. 查询有嵌套关系的对象（如 `shipment` 和 `shipment_item`）时，应该在 `**Mapper.xml` 中编写 SQL 语句并使用联表查询减少与数据库的交互次数，避免性能问题
3. 逻辑要求
    1. （当前逻辑未实现）订单（orders）领域在将订单的状态 `orders.status` 推进为 `PAID` 后，需要插入一张占位物流单（包括 `shipping`  本身和其对应的 `shipment_item`），以及对应的 `shipment_status_log`，这张占位物流单只需要填写 `id, shipment_no, order_id, idempotency_key, status, ship_from, ship_to, declared_value, currency`  这些字段；订单 `PAID` 状态推进必须成功落库，而占位单及状态转移日志的插入属于可补偿的动作，在插入动作失败时不应该回滚订单状态推进的操作，避免支付成功却因物流写失败把支付链路拖垮
    2. `/admin/shipments/{shipment_id}/label` 接口用途详细说明：这个接口用于管理员查看到有发货请求（即占位单）后，向承运商申请面单后进行详细信息回填，回填信息后需要根据 17Track 的 API 文档向 17Track 注册单号，具体端点和操作可以使用 Context7 获取 17Track 的API文档查看，并且需要避免在事务中调用外部 API（使用 `**Port`）以避免长事务或占用锁时间过长带来的性能问题
    3. 由于占位物流单的插入属于可补偿动作，因此需要有一个低频定时任务定期扫描 `orders.status=PAID` 且无 `shipment` 的订单，并进行占位物流单的补建
    4. `/admin/shipments/manual-create` 接口用途详细说明：由于占位单的插入属于可补偿动作，因此当正常插入链路失败，而又因为某种原因定时任务补偿也失效时，可使用该接口进行人工物流单补建
    5. 所有 `POST` 接口必须幂等（包括shipping领域的写接口和订单领域中插入占位物流单的逻辑，但不包括 WebHook接口）
    6. 所有推进物流单状态的动作（包括但不限于发货，回填物流面单信息，17Track 回调更新物流单状态，低频定时任务主动更新物流单状态等操作）需要统一走 `shopping.international.domain.model.aggregate.shipping.Shipment#applyTrackingEvent` 方法，避免两套及以上的实现逻辑导致流程不一致
    7. `/webhooks/17track` 接口的描述中提到 WebHook 请求必须验签和去重，验签方式你可以使用 Context7 获取 17Track 的API文档，去重则需要我们系统自行实现（与支付（payment）领域一样使用Redis）
    8. `/webhooks/17track` 接口的描述中提到的 17Track的 `sub_status` 枚举以及含义你可以 Context7 获取 17Track 的API文档进行查看，并创建枚举类以便管理，不要在代码中硬编码状态
    9. `/webhooks/17track` 接口的描述中提到的 **终态规则，状态流转矩阵，目标状态允许来源**，状态线性优先级 已经在 `shopping.international.domain.model.enums.shipping.ShipmentStatus` @ShipmentStatus 中实现
    10. （当前逻辑未实现）需要在订单（orders）领域的修改地址相关逻辑中，添加对 `shipment.status` 的状态校验，只有在 `shipment.status={CREATED, LABEL_CREATED}` 时才允许修改地址
    11. 在某个物流单的 `shipment.status` 的状态被推进为 `DELIVERED` 时，检查其所属的订单是否**存在**关联的物流单（避免空集为真）且订单关联的所有物流单都 `shipment.status = DELIVERED` 时，尝试将订单的 `orders.status` 推进为 `FULFILLED`，并写订单状态流转日志
4. 并发和幂等要求：
    1. 所有写接口（shipping领域下为 `POST` 但不包括 WebHook接口）都需要做幂等，在 @international-shopping-shipping-api.yaml 接口文档中要求请求头必须传入 `Idempotency-Key`
    2. infrastructure层对数据库的写操作需要使用 CAS，状态机或 update 不成功时回读等操作来避免并发导致的修改不成功或修改结果被覆盖的问题
    3. infrastructure层对数据库的写操作需要避免与订单（orders）或支付（payment）领域的 infrastructure 层写操作获取锁的顺序相反或循环获取锁，以避免发生死锁或锁超时问题，但是不要滥用 `select ... for update` 锁，以锁占用时间过久导致性能问题
5. 你编写的所有类，以及类中的所有方法和字段，都需要补充上完整的中文 JavaDoc

