现在我需要实现用户（user）领域的shopping.international.domain.service.user.IBindingService服务接口，实现类命名应该为BindingService，我将为你提供我们之前一起编写的shopping.international.trigger.controller.user.BindingController，以及其相关的领域服务接口，以及我们之前已经实现过的关于用户的Repository的实现和OAuth2认证相关的实现，请你根据实际情况，告知我哪些部分需要新增，哪些部分需要修改，并给出相应的代码，如果你需要新增对用户仓储数据的操作，请直接修改shopping.international.infrastructure.adapter.repository.user.UserRepository类，在类中新增你所需要的方法，由于我们之前开发用户登录注册以及第三方鉴权接口时，已经构建好了用户（user）领域中相关四张表的PO，他们分别是user_account ，user_auth ，user_profile ，user_address，分别对应UserAccountPO，UserAuthPO，UserProfilePO，UserAddressPO（我在下方会给出），你可以继续沿用，请你继续按照我提供的代码的编码风格以及命名格式为我实现这个服务，并且，与infrastructure相关的操作请下沉到infrastructure层（如使用@Transactional开启事务等）同样的，你需要为你编写的所有类，所有方法，所有属性，都加上完整的JavaDoc

// shopping.international.trigger.controller.user.BindingController
package shopping.international.trigger.controller.user;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.csrf.CsrfToken;
import org.springframework.security.web.csrf.CsrfTokenRepository;
import org.springframework.web.bind.annotation.*;
import shopping.international.api.resp.Result;
import shopping.international.api.resp.user.RedirectUrlRespond;
import shopping.international.api.resp.user.UserAuthBindingRespond;
import shopping.international.domain.model.entity.user.AuthBinding;
import shopping.international.domain.model.enums.user.AuthProvider;
import shopping.international.domain.model.vo.user.OAuth2CallbackResult;
import shopping.international.domain.service.user.IBindingService;
import shopping.international.types.constant.SecurityConstants;
import shopping.international.types.exceptions.AccountException;

import java.util.List;
import java.util.regex.Pattern;

import static shopping.international.types.utils.FieldValidateUtils.*;

/**
 * 第三方账号绑定/解绑 控制器
 * <p>
 * 约定:
 * <ul>
 *     <li>
 *         发起绑定: {@code GET /user/bindings/{provider}/authorize?redirectUrl=...}<br/>
 *         返回 data.url (前端跳转至第三方授权页)
 *     </li>
 *     <li>
 *         回调完成绑定: {@code GET /user/bindings/oauth2/{provider}/callback?code=...&state=...}<br/>
 *         内部完成绑定并 302 到前端 redirectUrl
 *     </li>
 *     <li>解绑: {@code DELETE /user/bindings/{provider}}</li>
 *     <li>列表: {@code GET /user/bindings}</li>
 * </ul>
 */
@RestController
@RequiredArgsConstructor
@RequestMapping(SecurityConstants.API_PREFIX + "/user/bindings")
public class BindingController {

    /**
     * 认证绑定服务
     */
    private final IBindingService bindingService;
    /**
     * CSRF 令牌存储器
     */
    private final CsrfTokenRepository csrfTokenRepository;

    /**
     * 查询当前用户的第三方绑定列表
     */
    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public Result<List<UserAuthBindingRespond>> list() {
        Long userId = requireCurrentUserId();
        List<AuthBinding> authBindingList = bindingService.listBindings(userId);
        List<UserAuthBindingRespond> userAuthBindingRespondList = authBindingList.stream()
                .map(UserAuthBindingRespond::from)
                .toList();
        return Result.ok(userAuthBindingRespondList);
    }

    /**
     * 发起 绑定意图 的第三方授权 (前端仅需拿到URL并跳转, 无需提交authCode)
     *
     * @param provider    第三方提供方
     * @param redirectUrl 绑定完成后的前端落地页
     */
    @GetMapping("/{provider}/authorize")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Result<RedirectUrlRespond>> authorize(@PathVariable("provider") AuthProvider provider,
                                                                @RequestParam(value = "redirectUrl") String redirectUrl) {
        requireNotNull(provider, "认证提供者不能为空");
        requireNotBlank(redirectUrl, "跳转地址不能为空");
        Pattern URL_REGEX = Pattern.compile("^https?://.*$");
        require(URL_REGEX.matcher(redirectUrl).matches(), "跳转地址格式错误");

        Long userId = requireCurrentUserId();
        String url = bindingService.buildBindAuthorizationUrl(userId, provider, redirectUrl);
        return ResponseEntity.status(HttpStatus.FOUND)
                .body(Result.found(new RedirectUrlRespond(url)));
    }

    /**
     * 处理 OAuth2 回调请求, 用于完成第三方登录或绑定流程
     *
     * @param provider         第三方提供商的标识, 例如 "google", "facebook" 等
     * @param code             从第三方服务获取的授权码
     * @param state            用于防止 CSRF 攻击的状态参数
     * @param error            如果有错误发生, 该参数将包含错误代码
     * @param errorDescription 错误描述信息, 当 {@code error} 参数存在时可能附带此信息
     * @param request          HTTP 请求对象, 用于处理 CSRF 令牌
     * @param response         HTTP 响应对象, 用于更新客户端的 CSRF 令牌
     * @return 包含重定向 URL 的响应实体, 根据操作结果返回不同的 HTTP 状态码
     * <p>
     * 如果绑定成功, 将返回状态码为 {@code 302 Found} 的响应, 并提供一个重定向 URL.
     * 若绑定失败, 则返回状态码为 {@code 400 Bad Request} 的响应, 同样包含一个重定向 URL 及错误信息.
     */
    @GetMapping("/oauth2/{provider}/callback")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Result<RedirectUrlRespond>> callback(@PathVariable("provider") AuthProvider provider,
                                                               @RequestParam(value = "code", required = false) String code,
                                                               @RequestParam(value = "state", required = false) String state,
                                                               @RequestParam(value = "error", required = false) String error,
                                                               @RequestParam(value = "error_description", required = false) String errorDescription,
                                                               HttpServletRequest request,
                                                               HttpServletResponse response) {
        Long userId = requireCurrentUserId();

        OAuth2CallbackResult result = bindingService.handleBindCallback(userId, provider, code, state, error, errorDescription);
        if (!result.isSuccess())
            return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                    .body(Result.of(
                            false,
                            shopping.international.types.enums.ApiCode.BAD_REQUEST,
                            provider.name() + " 绑定错误",
                            new RedirectUrlRespond(result.getRedirectUrl()),
                            null
                    ));

        // 轮换 CSRF (与登录回调保持一致的安全姿势)
        CsrfToken token = csrfTokenRepository.generateToken(request);
        csrfTokenRepository.saveToken(token, request, response);

        return ResponseEntity.status(HttpStatus.FOUND)
                .body(Result.found(new RedirectUrlRespond(result.getRedirectUrl())));
    }

    /**
     * 解绑指定 provider 的第三方账号
     *
     * @param provider 认证提供者, 例如 "google", "facebook" 等
     * @return 返回一个 {@link Result} 对象, 包含解绑操作的结果信息. 如果解绑成功, 则返回状态为成功的 {@code Result} 对象, 并携带消息 "解绑成功"
     */
    @DeleteMapping("/{provider}")
    @PreAuthorize("isAuthenticated()")
    public Result<Void> unbind(@PathVariable("provider") AuthProvider provider) {
        requireNotNull(provider, "认证提供者不能为空");
        Long userId = requireCurrentUserId();
        bindingService.unbind(userId, provider);
        return Result.ok("解绑成功");
    }

    // ========================= 内部工具方法 =========================

    /**
     * 获取当前登录用户的ID 如果用户未登录或无法解析用户信息, 则抛出异常
     *
     * @return 当前登录用户的ID, 类型为 {@code Long}
     * @throws AccountException 如果用户未登录或用户信息无法被解析成Long类型
     */
    private Long requireCurrentUserId() {
        Authentication authentication = null;
        if (SecurityContextHolder.getContext() == null)
            authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !authentication.isAuthenticated())
            throw new AccountException("未登录");
        Object principal = authentication.getPrincipal();
        if (principal instanceof Long longUserId)
            return longUserId;
        if (principal instanceof String stringUserId)
            return Long.parseLong(stringUserId);
        throw new AccountException("无法解析当前用户");
    }
}

// shopping.international.domain.service.user.IBindingService
package shopping.international.domain.service.user;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import shopping.international.domain.model.entity.user.AuthBinding;
import shopping.international.domain.model.enums.user.AuthProvider;
import shopping.international.domain.model.vo.user.OAuth2CallbackResult;

import java.util.List;

/**
 * 第三方账号绑定/解绑 应用服务
 * <p>
 * 说明:
 * - 绑定发起阶段: 生成第三方授权URL并记录一次性state (携带BIND意图与userId)
 * - 回调阶段: 校验state并完成与当前用户的绑定 (不需要前端传authCode)
 * - 解绑阶段: 按provider (或你需要时可扩展为按bindingId)解除绑定
 */
public interface IBindingService {

    /**
     * 查询当前用户的绑定列表
     *
     * @param userId 当前登录用户ID
     * @return 用户的认证绑定列表, 包含所有与该用户关联的第三方认证信息, 每个 {@link AuthBinding} 对象代表一个认证绑定
     */
    @NotNull
    List<AuthBinding> listBindings(@NotNull Long userId);

    /**
     * 构建用于第三方账号绑定的授权 URL
     *
     * @param userId      用户ID, 用于标识当前用户
     * @param provider    第三方认证提供方, 指定要绑定的第三方服务
     * @param redirectUrl 绑定成功后的重定向 URL, 可选参数, 如果为空则使用默认值
     * @return 授权 URL 字符串, 用于引导用户前往第三方平台进行授权操作
     */
    @NotNull
    String buildBindAuthorizationUrl(@NotNull Long userId, @NotNull AuthProvider provider, @Nullable String redirectUrl);


    /**
     * 处理第三方账号绑定回调, 根据提供的参数校验并完成与当前用户的绑定
     *
     * @param expectedUserId   预期的用户ID, 用于验证回调请求是否属于该用户
     * @param provider         第三方认证提供方, 指定要绑定的第三方服务
     * @param code             授权码, 由第三方平台在授权成功后返回
     * @param state            状态标识, 用于防止跨站请求伪造攻击, 通常为生成授权URL时附带的一次性随机字符串
     * @param error            错误信息, 如果有错误发生则由第三方平台返回
     * @param errorDescription 错误描述, 提供更详细的错误信息
     * @return OAuth2CallbackResult 对象, 包含处理结果及可能的令牌信息和重定向URL, 详情见 {@link OAuth2CallbackResult}
     */
    @NotNull
    OAuth2CallbackResult handleBindCallback(@NotNull Long expectedUserId, @NotNull AuthProvider provider,
                                            @Nullable String code, @Nullable String state,
                                            @Nullable String error, @Nullable String errorDescription);

    /**
     * 解除指定用户与第三方认证提供方之间的绑定关系
     *
     * @param userId   用户ID, 指定要解绑的用户
     * @param provider 第三方认证提供方, 指定要解除绑定的服务
     */
    void unbind(@NotNull Long userId, @NotNull AuthProvider provider);
}

// shopping.international.domain.adapter.repository.user.IUserRepository
package shopping.international.domain.adapter.repository.user;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import shopping.international.domain.model.aggregate.user.User;
import shopping.international.domain.model.enums.user.AccountStatus;
import shopping.international.domain.model.enums.user.AuthProvider;
import shopping.international.domain.model.vo.user.*;

import java.time.LocalDateTime;
import java.util.Optional;

/**
 * 用户聚合的仓储接口 (面向领域层), 负责对 {@code user_account / user_auth / user_profile / user_address} 等
 * 多表的组合装配与持久化, 具体 ORM/SQL 由基础设施层实现
 *
 * <p><b>注意: </b>该接口设计为“一站式”聚合仓储, 屏蔽聚合内多实体 (含绑定) 的物理落地细节</p>
 */
public interface IUserRepository {

    /**
     * 按登录账号查询用户 (账号为用户名 / 邮箱 / 手机号), 返回完整聚合快照 (含绑定)
     *
     * @param account 用户名 / 邮箱 / 手机号
     * @return 用户聚合, 可为空
     */
    Optional<User> findByLoginAccount(@NotNull String account);

    /**
     * 按邮箱精确查询用户 (用于激活等流程), 返回完整聚合快照
     *
     * @param email 邮箱
     * @return 用户聚合, 可为空
     */
    Optional<User> findByEmail(@NotNull EmailAddress email);

    /**
     * 按主键查询用户
     *
     * @param userId 用户 ID
     * @return 用户聚合, 可为空
     */
    Optional<User> findById(@NotNull Long userId);

    /**
     * 检查用户名是否已存在 (幂等注册前置唯一性校验)
     *
     * @param username 用户名
     * @return 是否存在
     */
    boolean existsByUsername(@NotNull Username username);

    /**
     * 检查邮箱是否已存在 (幂等注册前置唯一性校验)
     *
     * @param email 邮箱
     * @return 是否存在 (忽略 null)
     */
    boolean existsByEmail(@NotNull EmailAddress email);

    /**
     * 检查手机号是否已存在 (幂等注册前置唯一性校验)
     *
     * @param phone 手机号
     * @return 是否存在 (忽略 null)
     */
    boolean existsByPhone(@NotNull PhoneNumber phone);

    /**
     * 按第三方身份 (issuer + provider_uid/sub) 查询用户
     *
     * @param issuer      OIDC iss (或等价发行方标识)
     * @param providerUid OIDC sub (发行方内用户唯一 ID)
     * @return 用户聚合
     */
    @NotNull Optional<User> findByProviderUid(@NotNull String issuer, @NotNull String providerUid);

    /**
     * 持久化一个全新的用户聚合 (账户 + 绑定 + 资料 + 地址)
     *
     * <p>要求 {@code user.id == null}, 至少存在一种登录方式
     * 若存在 LOCAL 绑定, 则其 passwordHash 必须非空
     * 成功后返回带持久化主键的快照 (含各子实体主键)</p>
     *
     * @param user 待保存的新用户对象, 包含用户账户、绑定信息、资料及地址等
     * @return 保存后的用户对象, 包括由数据库生成的主键和其他相关字段
     */
    @NotNull User saveNewUserWithBindings(User user);

    /**
     * 更新账户状态 (如 DISABLED → ACTIVE)
     *
     * @param userId 用户 ID
     * @param status 新状态
     */
    void updateStatus(@NotNull Long userId, @NotNull AccountStatus status);

    /**
     * 记录登录时间戳与通道最近登录时间 (如 provider=LOCAL)
     *
     * @param userId    用户 ID
     * @param provider  认证提供方
     * @param loginTime 登录时间
     */
    void recordLogin(@NotNull Long userId, @NotNull AuthProvider provider, @NotNull LocalDateTime loginTime);

    /**
     * 检查是否存在手机号相同的其他用户, 排除指定的用户 ID
     *
     * @param userId 用户 ID 需要排除的用户 ID, 用于避免查询到当前用户自己
     * @param phone  手机号 要检查的手机号, 必须是有效的 {@link PhoneNumber} 对象
     * @return 是否存在 如果存在其他用户的手机号与给定的手机号相同, 返回 true; 否则返回 false
     */
    boolean existsByPhoneExceptUser(@NotNull Long userId, @NotNull PhoneNumber phone);

    /**
     * 更新指定用户ID的昵称和手机号
     *
     * @param userId   用户ID, 必须提供
     * @param nickname 新的昵称, 可以是 {@code null}, 如果为 {@code null} 则不更新昵称
     * @param phone    新的手机号, 可以是 {@code null}, 如果为 {@code null} 则不更新手机号
     * @throws IllegalStateException 当尝试更新不存在或已删除的用户时抛出
     */
    void updateNicknameAndPhone(@NotNull Long userId, @Nullable Nickname nickname, @Nullable PhoneNumber phone);

    /**
     * 更新指定用户的邮箱地址
     *
     * @param userId   用户ID, 必须提供
     * @param newEmail 新的邮箱地址, 必须提供
     * @throws IllegalStateException 当尝试更新不存在或已删除的用户时抛出
     */
    void updateEmail(@NotNull Long userId, @NotNull EmailAddress newEmail);

    /**
     * 插入或更新用户资料信息. 如果指定的用户ID不存在, 则插入新的用户资料, 如果存在, 则更新现有资料
     *
     * @param userId  用户ID, 用于识别用户
     * @param profile 用户资料对象, 包含了用户的显示名称, 头像URL, 性别, 生日, 国家, 省份, 城市, 地址行, 邮政编码以及额外信息等
     * @throws IllegalArgumentException 如果传入的参数不符合要求 (例如, userId 为 null, 或者 profile 为 null)
     */
    void upsertProfile(@NotNull Long userId, @NotNull UserProfile profile);
}

// shopping.international.infrastructure.adapter.repository.user.UserRepository
package shopping.international.infrastructure.adapter.repository.user;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;
import shopping.international.domain.adapter.repository.user.IUserRepository;
import shopping.international.domain.model.aggregate.user.User;
import shopping.international.domain.model.entity.user.AuthBinding;
import shopping.international.domain.model.entity.user.UserAddress;
import shopping.international.domain.model.enums.user.AccountStatus;
import shopping.international.domain.model.enums.user.AuthProvider;
import shopping.international.domain.model.enums.user.Gender;
import shopping.international.domain.model.vo.user.*;
import shopping.international.infrastructure.dao.user.UserAccountMapper;
import shopping.international.infrastructure.dao.user.UserAddressMapper;
import shopping.international.infrastructure.dao.user.UserAuthMapper;
import shopping.international.infrastructure.dao.user.UserProfileMapper;
import shopping.international.infrastructure.dao.user.po.UserAccountPO;
import shopping.international.infrastructure.dao.user.po.UserAddressPO;
import shopping.international.infrastructure.dao.user.po.UserAuthPO;
import shopping.international.infrastructure.dao.user.po.UserProfilePO;
import shopping.international.types.exceptions.IllegalParamException;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static shopping.international.types.utils.FieldValidateUtils.requireNotBlank;

/**
 * 基于 MyBatis-Plus 的用户聚合仓储实现
 * <p>职责: 按聚合粒度对 {@code user_account / user_auth / user_profile / user_address} 进行组合读写</p>
 */
@Slf4j
@Repository
@RequiredArgsConstructor
public class UserRepository implements IUserRepository {

    /**
     * user_account Mapper
     */
    private final UserAccountMapper accountMapper;
    /**
     * user_auth Mapper
     */
    private final UserAuthMapper authMapper;
    /**
     * user_profile Mapper
     */
    private final UserProfileMapper profileMapper;
    /**
     * user_address Mapper
     */
    private final UserAddressMapper addressMapper;
    /**
     * JSON 序列化/反序列化工具
     */
    private final ObjectMapper mapper;

    // ========================= 查询 =========================

    /**
     * 按登录账号查询用户 (账号为用户名 / 邮箱 / 手机号), 返回完整聚合快照 (含绑定)
     *
     * @param account 用户名 / 邮箱 / 手机号
     * @return 用户聚合, 可为空
     */
    @Override
    public Optional<User> findByLoginAccount(@NotNull String account) {
        UserAccountPO po = accountMapper.selectOne(new LambdaQueryWrapper<UserAccountPO>()
                .eq(UserAccountPO::getUsername, account)
                .or(wrapper -> wrapper.eq(UserAccountPO::getEmail, account))
                .or(wrapper -> wrapper.eq(UserAccountPO::getPhone, account))
                .eq(UserAccountPO::getIsDeleted, Boolean.FALSE)
                .last("limit 1"));
        return assembleOptional(po);
    }

    /**
     * 按邮箱精确查询用户 (用于激活等流程), 返回完整聚合快照
     *
     * @param email 邮箱
     * @return 用户聚合, 可为空
     */
    @Override
    public Optional<User> findByEmail(@NotNull EmailAddress email) {
        UserAccountPO po = accountMapper.selectOne(new LambdaQueryWrapper<UserAccountPO>()
                .eq(UserAccountPO::getEmail, email.getValue())
                .eq(UserAccountPO::getIsDeleted, Boolean.FALSE)
                .last("limit 1"));
        return assembleOptional(po);
    }

    /**
     * 按主键查询用户
     *
     * @param userId 用户 ID
     * @return 用户聚合, 可为空
     */
    @Override
    public Optional<User> findById(@NotNull Long userId) {
        UserAccountPO po = accountMapper.selectById(userId);
        if (po == null || Boolean.TRUE.equals(po.getIsDeleted()))
            return Optional.empty();
        return assembleOptional(po);
    }

    /**
     * 检查用户名是否已存在 (幂等注册前置唯一性校验)
     *
     * @param username 用户名
     * @return 是否存在
     */
    @Override
    public boolean existsByUsername(@NotNull Username username) {
        Long n = accountMapper.selectCount(new LambdaQueryWrapper<UserAccountPO>()
                .eq(UserAccountPO::getUsername, username.getValue())
                .eq(UserAccountPO::getIsDeleted, Boolean.FALSE));
        return n != null && n > 0;
    }

    /**
     * 检查邮箱是否已存在 (幂等注册前置唯一性校验)
     *
     * @param email 邮箱
     * @return 是否存在 (忽略 null)
     */
    @Override
    public boolean existsByEmail(@NotNull EmailAddress email) {
        Long n = accountMapper.selectCount(new LambdaQueryWrapper<UserAccountPO>()
                .eq(UserAccountPO::getEmail, email.getValue())
                .eq(UserAccountPO::getIsDeleted, Boolean.FALSE));
        return n != null && n > 0;
    }

    /**
     * 检查手机号是否已存在 (幂等注册前置唯一性校验)
     *
     * @param phone 手机号
     * @return 是否存在 (忽略 null)
     */
    @Override
    public boolean existsByPhone(@NotNull PhoneNumber phone) {
        Long n = accountMapper.selectCount(new LambdaQueryWrapper<UserAccountPO>()
                .eq(UserAccountPO::getPhone, phone.getValue())
                .eq(UserAccountPO::getIsDeleted, Boolean.FALSE));
        return n != null && n > 0;
    }

    /**
     * 按第三方身份 (issuer + provider_uid/sub) 查询用户
     *
     * @param issuer      OIDC iss (或等价发行方标识)
     * @param providerUid OIDC sub (发行方内用户唯一 ID)
     * @return 用户聚合
     */
    @Override
    public @NotNull Optional<User> findByProviderUid(@NotNull String issuer, @NotNull String providerUid) {
        UserAuthPO auth = authMapper.selectOne(new LambdaQueryWrapper<UserAuthPO>()
                .eq(UserAuthPO::getIssuer, issuer)
                .eq(UserAuthPO::getProviderUid, providerUid)
                .last("limit 1"));
        if (auth == null)
            return Optional.empty();
        UserAccountPO account = accountMapper.selectById(auth.getUserId());
        if (account == null || Boolean.TRUE.equals(account.getIsDeleted()))
            return Optional.empty();
        return assembleOptional(account);
    }

    // ========================= 写入 =========================

    /**
     * 持久化一个全新的用户聚合 (账户 + 绑定 + 资料 + 地址)
     *
     * <p>要求 {@code user.id == null}, 至少存在一种登录方式
     * 若存在 LOCAL 绑定, 则其 passwordHash 必须非空
     * 成功后返回带持久化主键的快照 (含各子实体主键)</p>
     *
     * @param user 待保存的新用户对象, 包含用户账户, 绑定信息, 资料及地址等
     * @return 保存后的用户对象, 包括由数据库生成的主键和其他相关字段
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public @NotNull User saveNewUserWithBindings(User user) {
        // 1. 入库 user_account
        requireNotBlank(user.getEmail().getValue(), "用户邮箱不能为空");
        UserAccountPO acc = UserAccountPO.builder()
                .username(user.getUsername().getValue())
                .nickname(user.getNickname().getValue())
                .email(user.getEmail().getValue())
                .phone(user.getPhone() == null ? null : user.getPhone().getValue())
                .status(user.getStatus() == null ? AccountStatus.DISABLED.name() : user.getStatus().name())
                .lastLoginAt(user.getLastLoginAt())
                .isDeleted(Boolean.FALSE)
                .build();
        accountMapper.insert(acc); // 自增主键回填
        Long userId = acc.getId();

        // 2. 入库 user_profile
        UserProfilePO profile = new UserProfilePO(
                userId,
                user.getProfile() == null ? null : user.getProfile().getDisplayName(),
                user.getProfile() == null ? null : user.getProfile().getAvatarUrl(),
                user.getProfile() == null ? Gender.UNKNOWN.name() : user.getProfile().getGender().name(),   // Gender → String
                user.getProfile() == null ? null : user.getProfile().getBirthday(),
                user.getProfile() == null ? null : user.getProfile().getCountry(),
                user.getProfile() == null ? null : user.getProfile().getProvince(),
                user.getProfile() == null ? null : user.getProfile().getCity(),
                user.getProfile() == null ? null : user.getProfile().getAddressLine(),
                user.getProfile() == null ? null : user.getProfile().getZipcode(),
                user.getProfile() == null ? null : toJsonOrNull(user.getProfile().getExtra()), // Map → JSON
                java.time.LocalDateTime.now(),
                java.time.LocalDateTime.now()
        );
        profileMapper.insert(profile);

        // 3. 入库 user_auth (遍历绑定)
        for (AuthBinding binding : user.getBindingsSnapshot()) {
            UserAuthPO authPO = UserAuthPO.builder()
                    .userId(userId)
                    .provider(binding.getProvider().name())
                    .issuer(binding.getIssuer())
                    .providerUid(binding.getProvider() == AuthProvider.LOCAL ? userId.toString() : binding.getProviderUid())
                    .passwordHash(binding.getPasswordHash())
                    .accessToken(binding.getAccessToken() == null ? null : binding.getAccessToken().getBytes())   // EncryptedSecret → bytes()
                    .refreshToken(binding.getRefreshToken() == null ? null : binding.getRefreshToken().getBytes())
                    .expiresAt(binding.getExpiresAt())
                    .scope(binding.getScope())
                    .role(binding.getRole())
                    .lastLoginAt(binding.getLastLoginAt())
                    .build();
            authMapper.insert(authPO);
        }

        // 4 入库 user_address
        if (user.getAddressesSnapshot() != null && !user.getAddressesSnapshot().isEmpty()) {
            for (UserAddress a : user.getAddressesSnapshot()) {
                UserAddressPO addressPO = UserAddressPO.builder()
                        .userId(userId)
                        .receiverName(a.getReceiverName())
                        .phone(a.getPhone() == null ? null : a.getPhone().getValue())
                        .country(a.getCountry())
                        .province(a.getProvince())
                        .city(a.getCity())
                        .district(a.getDistrict())
                        .addressLine1(a.getAddressLine1())
                        .addressLine2(a.getAddressLine2())
                        .zipcode(a.getZipcode())
                        .isDefault(a.isDefaultAddress())
                        .build();
                addressMapper.insert(addressPO);
            }
        }

        // 5. 回读聚合 (含各子表主键)
        return findById(userId).orElseThrow(() -> new IllegalStateException("保存后回读用户失败"));
    }

    /**
     * 更新账户状态 (如 DISABLED → ACTIVE)
     *
     * @param userId 用户 ID
     * @param status 新状态
     */
    @Override
    public void updateStatus(@NotNull Long userId, @NotNull AccountStatus status) {
        accountMapper.update(null, new LambdaUpdateWrapper<UserAccountPO>()
                .eq(UserAccountPO::getId, userId)
                .set(UserAccountPO::getStatus, status.name()));
    }

    /**
     * 记录登录时间戳与通道最近登录时间 (如 provider=LOCAL)
     *
     * @param userId    用户 ID
     * @param provider  认证提供方
     * @param loginTime 登录时间
     */
    @Override
    public void recordLogin(@NotNull Long userId, @NotNull AuthProvider provider, @NotNull LocalDateTime loginTime) {
        // 1) 更新账户最近登录
        accountMapper.update(null, new LambdaUpdateWrapper<UserAccountPO>()
                .eq(UserAccountPO::getId, userId)
                .set(UserAccountPO::getLastLoginAt, loginTime));
        // 2) 更新对应通道最近登录
        authMapper.update(null, new LambdaUpdateWrapper<UserAuthPO>()
                .eq(UserAuthPO::getUserId, userId)
                .eq(UserAuthPO::getProvider, provider.name())
                .set(UserAuthPO::getLastLoginAt, loginTime));
    }

    // ========================= 增量写入 (本次新增) =========================

    /**
     * 检查是否存在手机号相同的其他用户, 排除指定的用户 ID
     *
     * @param userId 用户 ID 需要排除的用户 ID, 用于避免查询到当前用户自己
     * @param phone  手机号 要检查的手机号, 必须是有效的 {@link PhoneNumber} 对象
     * @return 是否存在 如果存在其他用户的手机号与给定的手机号相同, 返回 true; 否则返回 false
     */
    @Override
    public boolean existsByPhoneExceptUser(@NotNull Long userId, @NotNull PhoneNumber phone) {
        Long count = accountMapper.selectCount(new LambdaQueryWrapper<UserAccountPO>()
                .eq(UserAccountPO::getPhone, phone.getValue())
                .eq(UserAccountPO::getIsDeleted, Boolean.FALSE)
                .ne(UserAccountPO::getId, userId));
        return count != null && count > 0;
    }


    /**
     * 更新指定用户ID的昵称和手机号
     *
     * @param userId   用户ID, 必须提供
     * @param nickname 新的昵称, 可以是 {@code null}, 如果为 {@code null} 则不更新昵称
     * @param phone    新的手机号, 可以是 {@code null}, 如果为 {@code null} 则不更新手机号
     * @throws IllegalStateException 当尝试更新不存在或已删除的用户时抛出
     */
    @Override
    public void updateNicknameAndPhone(@NotNull Long userId, @Nullable Nickname nickname, @Nullable PhoneNumber phone) {
        LambdaUpdateWrapper<UserAccountPO> updateWrapper = new LambdaUpdateWrapper<UserAccountPO>()
                .eq(UserAccountPO::getId, userId)
                .eq(UserAccountPO::getIsDeleted, Boolean.FALSE);

        boolean needUpdate = false;
        if (nickname != null) {
            updateWrapper.set(UserAccountPO::getNickname, nickname.getValue());
            needUpdate = true;
        }
        if (phone != null) {
            updateWrapper.set(UserAccountPO::getPhone, phone.getValue());
            needUpdate = true;
        }
        if (!needUpdate)
            // 无字段需要更新, 直接返回
            return;

        int rows = accountMapper.update(null, updateWrapper);
        if (rows == 0)
            throw new IllegalStateException("更新失败, 用户不存在或已删除");
    }


    /**
     * 更新指定用户的邮箱地址
     *
     * @param userId   用户ID, 必须提供
     * @param newEmail 新的邮箱地址, 必须提供
     * @throws IllegalStateException 当尝试更新不存在或已删除的用户时抛出
     */
    @Override
    public void updateEmail(@NotNull Long userId, @NotNull EmailAddress newEmail) {
        int rows;
        try {
            rows = accountMapper.update(null, new LambdaUpdateWrapper<UserAccountPO>()
                    .eq(UserAccountPO::getId, userId)
                    .eq(UserAccountPO::getIsDeleted, Boolean.FALSE)
                    .set(UserAccountPO::getEmail, newEmail.getValue()));
        } catch (DataIntegrityViolationException ex) {
            // 与并发竞争或唯一约束冲突对齐
            throw new IllegalParamException("邮箱已被使用");
        }
        if (rows == 0)
            throw new IllegalStateException("更新失败: 用户不存在或已删除");
    }


    /**
     * 插入或更新用户资料信息. 如果指定的用户ID不存在, 则插入新的用户资料, 如果存在, 则更新现有资料
     *
     * @param userId  用户ID, 用于识别用户
     * @param profile 用户资料对象, 包含了用户的显示名称, 头像URL, 性别, 生日, 国家, 省份, 城市, 地址行, 邮政编码以及额外信息等
     * @throws IllegalArgumentException 如果传入的参数不符合要求 (例如, userId 为 null, 或者 profile 为 null)
     */
    @Override
    public void upsertProfile(@NotNull Long userId, @NotNull UserProfile profile) {
        // 先取一次, 判断是否存在
        UserProfilePO existed = profileMapper.selectById(userId);

        String gender = profile.getGender().name();
        if (existed == null) {
            // 插入
            UserProfilePO toInsert = new UserProfilePO(
                    userId,
                    profile.getDisplayName(),
                    profile.getAvatarUrl(),
                    gender,
                    profile.getBirthday(),
                    profile.getCountry(),
                    profile.getProvince(),
                    profile.getCity(),
                    profile.getAddressLine(),
                    profile.getZipcode(),
                    toJsonOrNull(profile.getExtra()),
                    null, // created_at 交由数据库默认
                    null  // updated_at 交由数据库默认
            );
            profileMapper.insert(toInsert);
        } else {
            // 更新 (仅设置可变字段, created_at/updated_at 交由 DB 维护)
            profileMapper.update(null, new LambdaUpdateWrapper<UserProfilePO>()
                    .eq(UserProfilePO::userId, userId)
                    .set(UserProfilePO::displayName, profile.getDisplayName())
                    .set(UserProfilePO::avatarUrl, profile.getAvatarUrl())
                    .set(UserProfilePO::gender, gender)
                    .set(UserProfilePO::birthday, profile.getBirthday())
                    .set(UserProfilePO::country, profile.getCountry())
                    .set(UserProfilePO::province, profile.getProvince())
                    .set(UserProfilePO::city, profile.getCity())
                    .set(UserProfilePO::addressLine, profile.getAddressLine())
                    .set(UserProfilePO::zipcode, profile.getZipcode())
                    .set(UserProfilePO::extra, toJsonOrNull(profile.getExtra()))
            );
        }
    }

    // ========================= 装配工具 =========================

    /**
     * 根据给定的用户账户持久化对象 <code>UserAccountPO</code>, 组装并返回一个完整的 <code>User</code> 对象封装在 <code>Optional</code> 中
     * 如果传入的 <code>UserAccountPO</code> 为 null, 则直接返回 <code>Optional.empty()</code>
     *
     * @param account 用户账户持久化对象, 包含用户的基本信息
     * @return 封装了完整用户信息 (包括但不限于基本资料, 认证绑定, 地址等) 的 <code>Optional<User></code> 实例,
     * 若无法组装或输入为空, 则返回 <code>Optional.empty()</code>
     */
    private Optional<User> assembleOptional(UserAccountPO account) {
        if (account == null)
            return Optional.empty();

        // 子表装载
        List<UserAuthPO> authList = authMapper.selectList(new LambdaQueryWrapper<UserAuthPO>()
                .eq(UserAuthPO::getUserId, account.getId()));
        List<UserAddressPO> addrList = addressMapper.selectList(new LambdaQueryWrapper<UserAddressPO>()
                .eq(UserAddressPO::getUserId, account.getId()));
        UserProfilePO profile = profileMapper.selectById(account.getId());

        // 映射子实体
        List<AuthBinding> bindings = authList.stream().map(this::toDomainAuth).toList();
        List<UserAddress> addresses = addrList.stream().map(this::toDomainAddress).toList();

        // Profile → 值对象 (你的 UserProfile API 若不同, 可在此适配)
        UserProfile profileVO = (profile == null) ? UserProfile.empty() : UserProfile.of(
                profile.displayName(),
                profile.avatarUrl(),
                parseGender(profile.gender()),
                profile.birthday(),
                profile.country(),
                profile.province(),
                profile.city(),
                profile.addressLine(),
                profile.zipcode(),
                parseJsonToMap(profile.extra())
        );

        requireNotBlank(account.getEmail(), "用户邮箱不能为空");
        // 还原聚合
        User user = User.reconstitute(
                account.getId(),
                Username.of(account.getUsername()),
                Nickname.of(account.getNickname()),
                EmailAddress.of(account.getEmail()),
                account.getPhone() == null ? null : PhoneNumber.nullableOf(account.getPhone()),
                AccountStatus.valueOf(account.getStatus()),
                account.getLastLoginAt(),
                Boolean.TRUE.equals(account.getIsDeleted()),
                account.getCreatedAt(),
                account.getUpdatedAt(),
                profileVO,
                bindings,
                addresses
        );
        return Optional.of(user);
    }

    /**
     * 将用户认证持久化对象转换为领域模型中的认证绑定实体
     *
     * @param authPO 用户认证持久化对象, 包含了用户认证所需的所有信息, 如提供商, 访问令牌等
     * @return 转换后的认证绑定实体, 代表了用户的某一种认证方式的详细信息
     */
    private AuthBinding toDomainAuth(UserAuthPO authPO) {
        return new AuthBinding(
                authPO.getId(),
                AuthProvider.valueOf(authPO.getProvider()),
                authPO.getIssuer(),
                authPO.getProviderUid(),
                authPO.getPasswordHash(),
                authPO.getAccessToken() == null ? null : EncryptedSecret.of(authPO.getAccessToken()),
                authPO.getRefreshToken() == null ? null : EncryptedSecret.of(authPO.getRefreshToken()),
                authPO.getExpiresAt(),
                authPO.getScope(),
                authPO.getRole(),
                authPO.getLastLoginAt(),
                authPO.getCreatedAt(),
                authPO.getUpdatedAt()
        );
    }

    /**
     * 将用户地址持久化对象转换为领域模型中的用户地址实体
     *
     * @param addressPO 用户地址持久化对象, 包含了用户地址的所有信息
     * @return 转换后的 {@link UserAddress} 实体, 代表用户的某个收货地址的详细信息
     */
    private UserAddress toDomainAddress(UserAddressPO addressPO) {
        return new UserAddress(
                addressPO.getId(),
                addressPO.getReceiverName(),
                addressPO.getPhone() == null ? null : PhoneNumber.nullableOf(addressPO.getPhone()),
                addressPO.getCountry(),
                addressPO.getProvince(),
                addressPO.getCity(),
                addressPO.getDistrict(),
                addressPO.getAddressLine1(),
                addressPO.getAddressLine2(),
                addressPO.getZipcode(),
                Boolean.TRUE.equals(addressPO.getIsDefault()),
                addressPO.getCreatedAt(),
                addressPO.getUpdatedAt()
        );
    }

    /**
     * 将原始字符串解析为性别枚举值
     *
     * @param raw 原始字符串, 代表性别的英文表示, 如 "MALE", "FEMALE" 或 "UNKNOWN"
     * @return 解析后的 {@link Gender} 枚举值, 如果输入为空或无法匹配任何已定义的枚举, 则返回 {@link Gender#UNKNOWN UNKNOWN}
     */
    private static Gender parseGender(String raw) {
        if (raw == null || raw.isBlank())
            return Gender.UNKNOWN;
        try {
            return Gender.valueOf(raw.toUpperCase());
        } catch (IllegalArgumentException ex) {
            return Gender.UNKNOWN;
        }
    }

    /**
     * 将 JSON 字符串解析为键值对映射
     *
     * @param json 待解析的 JSON 字符串, 可以是任何有效的 JSON 格式字符串, 如果为空或空白, 则返回空映射
     * @return 解析后的键值对映射, 其中键为字符串, 值可以是任意类型, 如果解析失败, 也返回空映射
     */
    private Map<String, Object> parseJsonToMap(String json) {
        if (json == null || json.isBlank())
            return Map.of();
        try {
            return mapper.readValue(json, new TypeReference<>() {
            });
        } catch (Exception e) {
            log.error("解析 JSON 字符串失败: {}", e.getMessage());
            return Map.of();
        }
    }

    /**
     * 将给定的键值对映射转换为 JSON 字符串, 如果映射为空或转换过程中发生异常, 则返回 null.
     *
     * @param map 待转换的键值对映射, 其中键为字符串类型, 值可以是任意对象. 如果 <code>map</code> 为 null 或空, 方法将直接返回 null.
     * @return 转换后的 JSON 字符串, 如果输入映射为空, 或在转换过程中遇到任何异常, 则返回 null.
     */
    private String toJsonOrNull(java.util.Map<String, Object> map) {
        if (map == null || map.isEmpty())
            return null;
        try {
            return mapper.writeValueAsString(map);
        } catch (Exception e) {
            // 失败时可以选择返回 null 或抛出受检异常, 这里回退为 null
            log.error("转换 JSON 字符串失败: {}", e.getMessage());
            return null;
        }
    }
}

// shopping.international.domain.adapter.port.user.IOAuth2RemotePort
package shopping.international.domain.adapter.port.user;

import org.jetbrains.annotations.NotNull;
import shopping.international.domain.model.vo.user.*;

/**
 * OAuth2/OIDC 远程交互端口
 * <p>职责: 与第三方授权服务器交互: 置换 Token, 验签并解析 ID Token, 获取 UserInfo</p>
 */
public interface IOAuth2RemotePort {

    /**
     * 授权码置换 Token (支持 PKCE)
     *
     * @param spec          提供方配置
     * @param code          授权码
     * @param redirectUri   授权阶段使用的 redirect_uri (必须完全一致)
     * @param codeVerifier  授权阶段生成的 code_verifier
     * @return Token 响应体
     */
    @NotNull OAuth2TokenResponse exchangeAuthorizationCode(@NotNull OAuth2ProviderSpec spec, @NotNull String code,
                                                           @NotNull String redirectUri, @NotNull String codeVerifier);

    /**
     * 验签并解析 ID Token (OIDC)
     *
     * @param spec    提供方配置 (包含 issuer, aud/clientId, jwkSetUri 等)
     * @param idToken 原始 id_token 字符串
     * @return 解析后的声明集
     */
    @NotNull OidcIdTokenClaims verifyAndParseIdToken(@NotNull OAuth2ProviderSpec spec, @NotNull String idToken);

    /**
     * 使用 access_token 获取用户信息 (如果配置了 userinfo 端点)
     *
     * @param spec         提供方配置
     * @param accessToken  访问令牌
     * @return 用户信息 (可能为空)
     */
    @NotNull OidcUserInfo fetchUserInfo(@NotNull OAuth2ProviderSpec spec, @NotNull String accessToken);
}

// shopping.international.infrastructure.adapter.port.user.OAuth2RemotePort
package shopping.international.infrastructure.adapter.port.user;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.jwk.source.JWKSourceBuilder;
import com.nimbusds.jose.proc.*;
import com.nimbusds.jose.util.DefaultResourceRetriever;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jose.jwk.source.JWKSource;
import com.nimbusds.jwt.proc.ConfigurableJWTProcessor;
import com.nimbusds.jwt.proc.DefaultJWTProcessor;
import lombok.RequiredArgsConstructor;
import okhttp3.ResponseBody;
import org.jetbrains.annotations.NotNull;
import org.springframework.stereotype.Component;
import retrofit2.Response;
import shopping.international.domain.adapter.port.user.IOAuth2RemotePort;
import shopping.international.domain.model.vo.user.*;
import shopping.international.infrastructure.gateway.user.IOAuth2TokenApi;
import shopping.international.infrastructure.gateway.user.IOidcUserInfoApi;
import shopping.international.infrastructure.gateway.user.dto.TokenRequest;
import shopping.international.infrastructure.gateway.user.dto.TokenRespond;
import shopping.international.infrastructure.gateway.user.dto.UserInfoRespond;
import shopping.international.types.exceptions.IllegalParamException;

import java.net.URL;
import java.time.Instant;
import java.util.*;

import static shopping.international.types.utils.FieldValidateUtils.requireNotBlank;

/**
 * IOAuth2RemotePort 的 Retrofit + Nimbus 实现
 *
 * <p>职责: </p>
 * <ul>
 *   <li>调用第三方 Token 端点（x-www-form-urlencoded）</li>
 *   <li>使用 Remote JWK Set 验证并解析 ID Token</li>
 *   <li>调用 UserInfo 端点获取用户信息</li>
 * </ul>
 */
@Component
@RequiredArgsConstructor
public class OAuth2RemotePort implements IOAuth2RemotePort {
    /**
     * JSON 处理器
     */
    private final ObjectMapper mapper;
    /**
     * @see IOAuth2TokenApi
     */
    private final IOAuth2TokenApi oauth2TokenApi;
    /**
     * @see IOidcUserInfoApi
     */
    private final IOidcUserInfoApi oidcUserInfoApi;

    /**
     * 授权码置换 Token (支持 PKCE)
     *
     * @param providerSpec 提供方配置
     * @param code         授权码
     * @param redirectUri  授权阶段使用的 redirect_uri (必须完全一致)
     * @param codeVerifier 授权阶段生成的 code_verifier
     * @return Token 响应体
     */
    @Override
    public @NotNull OAuth2TokenResponse exchangeAuthorizationCode(@NotNull OAuth2ProviderSpec providerSpec, @NotNull String code,
                                                                  @NotNull String redirectUri, @NotNull String codeVerifier) {
        try {
            TokenRequest request = TokenRequest.builder()
                    .code(code)
                    .redirectUri(redirectUri)
                    .clientId(providerSpec.clientId())
                    .clientSecret(providerSpec.clientSecret())
                    .codeVerifier(codeVerifier)
                    .build();

            Response<ResponseBody> resp = oauth2TokenApi.exchangeCode(providerSpec.tokenEndpoint(), request.toFieldMap()).execute();
            try (ResponseBody body = resp.body(); ResponseBody errorBody = resp.errorBody()) {
                if (!resp.isSuccessful() || body == null)
                    throw new IllegalParamException("Token 置换失败, HTTP " + resp.code() + " 错误体: " + errorBody);

                TokenRespond respond = mapper.readValue(body.bytes(), TokenRespond.class);

                return new OAuth2TokenResponse(
                        respond.getAccessToken(),
                        respond.getExpiresIn(),
                        respond.getIdToken(),
                        respond.getRefreshToken(),
                        normalizeScope(respond.getScope()),
                        respond.getTokenType()
                );
            }
        } catch (Exception e) {
            throw new IllegalParamException("Token 置换异常: " + e.getMessage());
        }
    }

    /**
     * 验签并解析 ID Token (OIDC)
     *
     * @param spec    提供方配置 (包含 issuer, aud/clientId, jwkSetUri 等)
     * @param idToken 原始 id_token 字符串
     * @return 解析后的声明集
     */
    @Override
    public @NotNull OidcIdTokenClaims verifyAndParseIdToken(@NotNull OAuth2ProviderSpec spec, @NotNull String idToken) {
        requireNotBlank(spec.issuer(), "缺少 issuer 配置以校验 id_token");
        requireNotBlank(spec.jwkSetUri(), "缺少 jwkSetUri 配置以校验 id_token");

        try {

            // 1. Nimbus JWT 处理器 + 远程 JWK
            HashSet<JWSAlgorithm> allowed = new HashSet<>(Arrays.asList(
                    JWSAlgorithm.RS256, JWSAlgorithm.PS256, JWSAlgorithm.ES256
            ));
            ConfigurableJWTProcessor<SecurityContext> processor = new DefaultJWTProcessor<>();
            // 配置资源检索器
            DefaultResourceRetriever retriever = new DefaultResourceRetriever(3000, 3000, 512 * 1024);
            // 构建 JWKSource
            JWKSource<SecurityContext> jwkSource = JWKSourceBuilder
                    .create(new URL(spec.jwkSetUri()), retriever)
                    .cache(15 * 60 * 1000, 5 * 1000)
                    .retrying(true)
                    .build();
            // 允许集合：内部会基于 header.alg 选用匹配的 Key
            JWSKeySelector<SecurityContext> keySelector = new JWSVerificationKeySelector<>(allowed, jwkSource);
            processor.setJWSKeySelector(keySelector);

            // 2 处理并得到 claims
            JWTClaimsSet claims = processor.process(idToken, null);

            // 3 手工做严格校验: iss/aud/time window
            String iss = String.valueOf(claims.getIssuer());
            if (!Objects.equals(iss, spec.issuer()))
                throw new IllegalParamException("id_token.iss 不匹配");

            List<String> aud = claims.getAudience();
            if (aud == null || aud.isEmpty() || !aud.contains(spec.clientId()))
                throw new IllegalParamException("id_token.aud 不包含本 client_id");

            Instant now = Instant.now();
            long skew = Math.max(0, spec.clockSkewSeconds());
            Date exp = claims.getExpirationTime();
            if (exp == null || now.isAfter(exp.toInstant().plusSeconds(skew)))
                throw new IllegalParamException("id_token 已过期");

            Date nbf = claims.getNotBeforeTime();
            if (nbf != null && now.isBefore(nbf.toInstant().minusSeconds(skew)))
                throw new IllegalParamException("id_token 尚未生效");

            // 4) 映射到领域 VO
            return new OidcIdTokenClaims(
                    iss,
                    aud,
                    claims.getSubject(),
                    toInstant(claims.getExpirationTime()),
                    toInstant(claims.getIssueTime()),
                    toInstant(claims.getNotBeforeTime()),
                    stringOrNull(claims.getClaim("nonce")),
                    stringOrNull(claims.getClaim("email")),
                    boolOrNull(claims.getClaim("email_verified")),
                    stringOrNull(claims.getClaim("name")),
                    stringOrNull(claims.getClaim("picture"))
            );
        } catch (IllegalParamException e) {
            throw e;
        } catch (Exception e) {
            throw new IllegalParamException("id_token 验签/解析失败: " + e.getMessage());
        }
    }

    /**
     * 使用 access_token 获取用户信息 (如果配置了 userinfo 端点)
     *
     * @param spec        提供方配置
     * @param accessToken 访问令牌
     * @return 用户信息 (可能为空)
     */
    @Override
    public @NotNull OidcUserInfo fetchUserInfo(@NotNull OAuth2ProviderSpec spec, @NotNull String accessToken) {
        requireNotBlank(spec.userinfoEndpoint(), "未配置 userinfoEndpoint, 无法获取用户信息");
        try {
            Response<ResponseBody> resp = oidcUserInfoApi.userInfo(spec.userinfoEndpoint(), "Bearer " + accessToken).execute();
            try (ResponseBody body = resp.body(); ResponseBody errorBody = resp.errorBody()) {
                if (!resp.isSuccessful() || body == null) {
                    throw new IllegalParamException("获取 UserInfo 失败, HTTP " + resp.code() + " 错误体: " + errorBody);
                }
                UserInfoRespond dto = mapper.readValue(body.bytes(), UserInfoRespond.class);
                return new OidcUserInfo(dto.getSub(), dto.getEmail(), dto.getEmailVerified(), dto.getName(), dto.getPicture());
            }
        } catch (Exception e) {
            throw new IllegalParamException("UserInfo 调用异常: " + e.getMessage());
        }
    }

    // ===== 工具 =====

    /**
     * 将给定的 scope 字符串进行规范化处理
     * 该方法会将空格分隔的多个 scope 转换为逗号分隔的形式, 并去除重复项和空白字符
     *
     * @param scope 待处理的原始 scope 字符串, 可以包含一个或多个由空格分隔的 scope 值
     * @return 处理后的 scope 字符串, 如果输入为空或只包含空白字符, 则返回 null
     */
    private static String normalizeScope(String scope) {
        if (scope == null || scope.isBlank())
            return null;
        // 将空格分隔的 scope 统一转为逗号分隔, 便于与领域聚合合并
        return String.join(",", Arrays.stream(scope.split("[\\s,]+"))
                .map(String::trim)
                .filter(s -> !s.isBlank())
                .distinct()
                .toList());
    }

    /**
     * 将给定的 <code>Date</code> 对象转换为 <code>Instant</code> 对象 如果输入为 null, 则返回 null
     *
     * @param date 输入的 <code>Date</code>
     * @return 转换后的 <code>Instant</code>
     */
    private static Instant toInstant(Date date) {
        return date == null ? null : date.toInstant();
    }

    /**
     * 将给定的对象转换为字符串, 如果对象为 <code>null</code>, 则返回 <code>null</code>
     *
     * @param object 输入的对象
     * @return 转换后的字符串
     */
    private static String stringOrNull(Object object) {
        return object == null ? null : String.valueOf(object);
    }

    /**
     * 将给定的对象转换为 <code>Boolean</code> 类型, 如果对象是 <code>null</code>, 则返回 <code>null</code>
     *
     * @param object 输入的对象, 可以是任何类型, 但只有当它是 <code>Boolean</code> 的实例时, 才会直接返回该布尔值, 否则, 会尝试将其转换为字符串再解析为布尔值
     * @return 如果输入对象是 <code>Boolean</code> 实例, 则直接返回该布尔值；如果对象可以被转换成表示真假的字符串, 返回对应的布尔值；如果对象为 <code>null</code> 或无法转换, 返回 <code>null</code>
     */
    private static Boolean boolOrNull(Object object) {
        if (object instanceof Boolean bool)
            return bool;
        return object == null ? null : Boolean.valueOf(String.valueOf(object));
    }
}

// shopping.international.domain.adapter.port.user.IOAuth2StatePort
package shopping.international.domain.adapter.port.user;

import org.jetbrains.annotations.NotNull;
import shopping.international.domain.model.vo.user.OAuth2EphemeralState;

import java.time.Duration;
import java.util.Optional;

/**
 * OAuth2 授权一次性状态存取端口
 * <p>职责: 存储并一次性弹出 state 对应的 {@code nonce, code_verifier, redirect, provider}</p>
 * <p>一般由 Redis 等 KV 存储实现，并设置合理 TTL</p>
 */
public interface IOAuth2StatePort {

    /**
     * 保存一次性授权上下文 (state → nonce/code_verifier/redirect/provider)
     *
     * @param state  上下文
     * @param ttl    过期时间
     */
    void storeEphemeral(@NotNull OAuth2EphemeralState state, @NotNull Duration ttl);

    /**
     * 根据 state 一次性弹出上下文 (读取即删除)
     *
     * @param state  state 字符串
     * @return 上下文, 不存在或过期返回空
     */
    @NotNull Optional<OAuth2EphemeralState> popByState(@NotNull String state);
}

// shopping.international.infrastructure.adapter.port.user.RedisOAuth2StatePort
package shopping.international.infrastructure.adapter.port.user;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import org.jetbrains.annotations.NotNull;
import org.springframework.data.redis.connection.RedisStringCommands;
import org.springframework.data.redis.connection.ReturnType;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.types.Expiration;
import org.springframework.stereotype.Component;
import shopping.international.domain.adapter.port.user.IOAuth2StatePort;
import shopping.international.domain.model.vo.user.OAuth2EphemeralState;

import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.Optional;

/**
 * 基于 Redis 的一次性 OAuth2 授权状态存取实现
 *
 * <p>键模式: {@code oauth2:state:{state}}, 值为 {@link OAuth2EphemeralState} 的 JSON 序列化
 * 存储时设置 TTL, 读取时采用“一次性弹出”的语义 (读到即删除), 优先使用 Redis 6+ 的
 * {@code GETDEL}, 若不支持则降级为原子 Lua 脚本 (GET+DEL)</p>
 *
 * <p><b>线程安全/并发语义: </b> 使用底层连接的原子命令或单条 EVAL, 确保多并发下只有一个消费者能成功弹出</p>
 */
@Component
@RequiredArgsConstructor
public class RedisOAuth2StatePort implements IOAuth2StatePort {

    /**
     * Key 前缀: oauth2:state:
     */
    private static final String KEY_PREFIX = "oauth2:state:";

    /**
     * Redis KV 客户端 (String 友好 API)
     */
    private final StringRedisTemplate redis;

    /**
     * JSON 序列化/反序列化器
     */
    private final ObjectMapper mapper;

    /**
     * 保存一次性授权上下文 (state → nonce/code_verifier/redirect/provider), 并设置 TTL
     *
     * <p>使用底层 {@code SET key value EX ttl} 语义, 重复写同一 state 将覆盖之前的值 (UPSERT)</p>
     *
     * @param state 上下文
     * @param ttl   过期时间 (必须为正)
     * @throws IllegalStateException 当 JSON 序列化失败时抛出
     */
    @Override
    public void storeEphemeral(@NotNull OAuth2EphemeralState state, @NotNull Duration ttl) {
        try {
            final String key = KEY_PREFIX + state.state();
            final String json = mapper.writeValueAsString(state);
            // 显式标注为 RedisCallback 以避免与 SessionCallback 重载二义性
            redis.execute((RedisCallback<Void>) connection -> {
                byte[] k = key.getBytes(StandardCharsets.UTF_8);
                byte[] v = json.getBytes(StandardCharsets.UTF_8);
                // SET key value EX ttl (UPSERT)
                connection.stringCommands().set(k, v, Expiration.from(ttl), RedisStringCommands.SetOption.UPSERT);
                return null;
            });
        } catch (JsonProcessingException e) {
            throw new IllegalStateException("序列化 OAuth2EphemeralState 失败", e);
        }
    }

    /**
     * 根据 state 一次性弹出上下文 (读取即删除)
     *
     * <p>优先尝试 Redis 6+ 的 {@code GETDEL}, 若底层驱动/服务端不支持, 则回退到 Lua 脚本实现
     * {@code local v=GET key; if v then DEL key; end; return v}, 确保原子性</p>
     *
     * @param state state 字符串
     * @return 上下文, 不存在或过期返回空
     */
    @Override
    public @NotNull Optional<OAuth2EphemeralState> popByState(@NotNull String state) {
        final String key = KEY_PREFIX + state;

        OAuth2EphemeralState result = redis.execute((RedisCallback<OAuth2EphemeralState>) connection -> {
            byte[] k = key.getBytes(StandardCharsets.UTF_8);
            byte[] raw;

            try {
                // 优先尝试 Redis 6+ GETDEL
                raw = connection.stringCommands().getDel(k);
            } catch (Throwable unsupported) {
                // 回退到原子 Lua: GET 然后 DEL, 并返回旧值
                // KEYS[1] = key; 返回值为 VALUE
                final byte[] script = "local v=redis.call('GET', KEYS[1]); if v then redis.call('DEL', KEYS[1]); end; return v"
                        .getBytes(StandardCharsets.UTF_8);
                raw = connection.scriptingCommands()
                        .eval(script, ReturnType.VALUE, 1, k);
            }

            if (raw == null)
                return null;
            try {
                return mapper.readValue(raw, OAuth2EphemeralState.class);
            } catch (Exception e) {
                // 反序列化失败：作废该状态, 返回 null
                return null;
            }
        });

        return Optional.ofNullable(result);
    }
}

// shopping.international.infrastructure.dao.user.po.UserAccountPO
package shopping.international.infrastructure.dao.user.po;

import com.baomidou.mybatisplus.annotation.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * 持久化对象: user_account
 * <p>映射用户账户主表 (JWT 认证), 用于 MyBatis-Plus CRUD</p>
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@TableName("user_account")
public class UserAccountPO {
    /**
     * 主键ID (自增)
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Long id;
    /**
     * 用户名(登录名)
     */
    @TableField("username")
    private String username;
    /**
     * 昵称/显示名
     */
    @TableField("nickname")
    private String nickname;
    /**
     * 邮箱
     */
    @TableField("email")
    private String email;
    /**
     * 手机号
     */
    @TableField("phone")
    private String phone;
    /**
     * 账户状态 (ACTIVE/DISABLED)
     */
    @TableField("status")
    private String status;
    /**
     * 最近登录时间
     */
    @TableField("last_login_at")
    private LocalDateTime lastLoginAt;
    /**
     * 软删除标记(0/1)
     */
    @TableField("is_deleted")
    private Boolean isDeleted;
    /**
     * 创建时间
     */
    @TableField(value = "created_at", insertStrategy = FieldStrategy.NEVER, updateStrategy = FieldStrategy.NEVER)
    private LocalDateTime createdAt;
    /**
     * 更新时间
     */
    @TableField(value = "updated_at", insertStrategy = FieldStrategy.NEVER, updateStrategy = FieldStrategy.NEVER)
    private LocalDateTime updatedAt;
}

// shopping.international.infrastructure.dao.user.po.UserAddressPO
package shopping.international.infrastructure.dao.user.po;

import com.baomidou.mybatisplus.annotation.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * 持久化对象: user_address
 * <p>用户收货地址 1:N</p>
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@TableName("user_address")
public class UserAddressPO {
    /**
     * 主键ID (自增)
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Long id;
    /**
     * 用户ID
     */
    @TableField("user_id")
    private Long userId;
    /**
     * 收货人
     */
    @TableField("receiver_name")
    private String receiverName;
    /**
     * 联系电话 (字符串持久化)
     */
    @TableField("phone")
    private String phone;
    /**
     * 国家
     */
    @TableField("country")
    private String country;
    /**
     * 省/州
     */
    @TableField("province")
    private String province;
    /**
     * 城市
     */
    @TableField("city")
    private String city;
    /**
     * 区/县
     */
    @TableField("district")
    private String district;
    /**
     * 地址行1
     */
    @TableField("address_line1")
    private String addressLine1;
    /**
     * 地址行2
     */
    @TableField("address_line2")
    private String addressLine2;
    /**
     * 邮编
     */
    @TableField("zipcode")
    private String zipcode;
    /**
     * 是否默认地址
     */
    @TableField("is_default")
    private Boolean isDefault;
    /**
     * 创建时间
     */
    @TableField(value = "created_at", insertStrategy = FieldStrategy.NEVER, updateStrategy = FieldStrategy.NEVER)
    private LocalDateTime createdAt;
    /**
     * 更新时间
     */
    @TableField(value = "updated_at", insertStrategy = FieldStrategy.NEVER, updateStrategy = FieldStrategy.NEVER)
    private LocalDateTime updatedAt;
}

// shopping.international.infrastructure.dao.user.po.UserAuthPO
package shopping.international.infrastructure.dao.user.po;

import com.baomidou.mybatisplus.annotation.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * 持久化对象: user_auth
 * <p>映射用户认证绑定 (本地/OAuth2)</p>
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@TableName("user_auth")
public class UserAuthPO {
    /**
     * 主键ID (自增)
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Long id;
    /**
     * 用户ID
     */
    @TableField("user_id")
    private Long userId;
    /**
     * 提供方 (LOCAL/GOOGLE/...)
     */
    @TableField("provider")
    private String provider;
    /**
     * 发行方 (OIDC iss)
     */
    @TableField("issuer")
    private String issuer;
    /**
     * 发行方内唯一ID (OIDC sub)
     */
    @TableField("provider_uid")
    private String providerUid;
    /**
     * 本地密码哈希 (仅 LOCAL)
     */
    @TableField("password_hash")
    private String passwordHash;
    /**
     * 访问令牌 (加密后字节)
     */
    @TableField("access_token")
    private byte[] accessToken;
    /**
     * 刷新令牌 (加密后字节)
     */
    @TableField("refresh_token")
    private byte[] refreshToken;
    /**
     * 访问令牌过期时间
     */
    @TableField("expires_at")
    private LocalDateTime expiresAt;
    /**
     * 授权范围 (逗号或空格分隔)
     */
    @TableField("scope")
    private String scope;
    /**
     * 角色
     */
    @TableField("role")
    private String role;
    /**
     * 该通道最近登录时间
     */
    @TableField("last_login_at")
    private LocalDateTime lastLoginAt;
    /**
     * 创建时间
     */
    @TableField(value = "created_at", insertStrategy = FieldStrategy.NEVER, updateStrategy = FieldStrategy.NEVER)
    private LocalDateTime createdAt;
    /**
     * 更新时间
     */
    @TableField(value = "updated_at", insertStrategy = FieldStrategy.NEVER, updateStrategy = FieldStrategy.NEVER)
    private LocalDateTime updatedAt;
}

// shopping.international.infrastructure.dao.user.po.UserProfilePO
package shopping.international.infrastructure.dao.user.po;

import com.baomidou.mybatisplus.annotation.FieldStrategy;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import java.time.LocalDate;
import java.time.LocalDateTime;

/**
 * 持久化对象：user_profile (record)
 * <p>用户资料 1:1；主键为 user_id, 非自增</p>
 *
 * <ol>
 *     <li>{@code userId: }用户ID (主键) </li>
 *     <li>{@code displayName: }显示名</li>
 *     <li>{@code avatarUrl: }头像URL</li>
 *     <li>{@code gender: }性别 (UNKNOWN/MALE/FEMALE) </li>
 *     <li>{@code birthday: }生日</li>
 *     <li>{@code country: }国家</li>
 *     <li>{@code province: }省/州</li>
 *     <li>{@code city: }城市</li>
 *     <li>{@code addressLine: }地址(简单场景)</li>
 *     <li>{@code zipcode: }邮编</li>
 *     <li>{@code extra: }扩展信息(JSON)</li>
 *     <li>{@code createdAt: }创建时间</li>
 *     <li>{@code updatedAt: }更新时间</li>
 * </ol>
 *
 * <p>注意：record 字段不可回填主键, 自增不适用；本表符合 record 的不可变场景</p>
 *
 */
@TableName("user_profile")
public record UserProfilePO(
        @TableId("user_id") Long userId,
        @TableField("display_name") String displayName,
        @TableField("avatar_url") String avatarUrl,
        @TableField("gender") String gender,
        @TableField("birthday") LocalDate birthday,
        @TableField("country") String country,
        @TableField("province") String province,
        @TableField("city") String city,
        @TableField("address_line") String addressLine,
        @TableField("zipcode") String zipcode,
        @TableField("extra") String extra,
        @TableField(value = "created_at", insertStrategy = FieldStrategy.NEVER, updateStrategy = FieldStrategy.NEVER)
        LocalDateTime createdAt,
        @TableField(value = "updated_at", insertStrategy = FieldStrategy.NEVER, updateStrategy = FieldStrategy.NEVER)
        LocalDateTime updatedAt
) {
}

