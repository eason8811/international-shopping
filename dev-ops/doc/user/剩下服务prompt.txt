现在我需要实现用户（user）领域的shopping.international.domain.service.user.IAddressService服务接口，实现类命名应该为AddressService服务接口，我将为你提供我们之前一起编写的shopping.international.trigger.controller.user.AddressController，以及其相关的领域服务接口，以及我们之前已经实现过的关于用户的Repository的实现，请你根据实际情况，告知我哪些部分需要新增，哪些部分需要修改，并给出相应的代码，如果你需要新增对用户仓储数据的操作，请直接修改shopping.international.infrastructure.adapter.repository.user.UserRepository类，在类中新增你所需要的方法，由于我们之前开发用户登录注册以及第三方鉴权接口时，已经构建好了用户（user）领域中相关四张表的PO，他们分别是user_account ，user_auth ，user_profile ，user_address，分别对应UserAccountPO，UserAuthPO，UserProfilePO，UserAddressPO（我在下方会给出），你可以继续沿用，请你继续按照我提供的代码的编码风格以及命名格式为我实现这个服务，并且，与infrastructure相关的操作请下沉到infrastructure层（如使用@Transactional开启事务等）同样的，你需要为你编写的所有类，所有方法，所有属性，都加上完整的JavaDoc

// shopping.international.trigger.controller.user.AddressController
package shopping.international.trigger.controller.user;

import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;
import shopping.international.api.req.user.CreateAddressRequest;
import shopping.international.api.req.user.UpdateAddressRequest;
import shopping.international.api.resp.Result;
import shopping.international.api.resp.user.AddressRespond;
import shopping.international.domain.model.entity.user.UserAddress;
import shopping.international.domain.model.vo.user.PhoneNumber;
import shopping.international.domain.service.user.IAddressService;
import shopping.international.types.constant.SecurityConstants;
import shopping.international.types.enums.ApiCode;
import shopping.international.types.exceptions.AccountException;

import java.util.List;

/**
 * 收货地址接口 {@code /users/me/addresses}
 *
 * <p>职责：
 * <ul>
 *   <li>列表, 详情</li>
 *   <li>新增, 修改, 删除</li>
 *   <li>设置默认地址 (同用户仅一个)</li>
 * </ul>
 * </p>
 */
@RestController
@RequiredArgsConstructor
@RequestMapping(SecurityConstants.API_PREFIX + "/users/me/addresses")
public class AddressController {

    /**
     * 地址领域服务
     */
    private final IAddressService addressService;


    /**
     * 获取当前登录用户的收货地址列表, 分页显示
     *
     * @param page 页码, 默认值为 1
     * @param size 每页显示的条目数, 默认值为 5
     * @return 包含分页信息和地址列表的结果集
     */
    @GetMapping
    public ResponseEntity<Result<List<AddressRespond>>> list(@RequestParam(defaultValue = "1") int page,
                                                             @RequestParam(defaultValue = "5") int size) {
        Long uid = requireCurrentUserId();
        IAddressService.PageResult pageData = addressService.list(uid, page, size);
        List<AddressRespond> data = pageData.items().stream().map(AddressRespond::from).toList();
        return ResponseEntity.ok(Result.ok(
                data,
                Result.Meta.builder()
                        .page(page)
                        .size(size)
                        .total(pageData.total())
                        .build()
        ));
    }

    /**
     * 创建新的收货地址
     *
     * <p>该方法用于用户创建一个新的收货地址, 需要提供接收者姓名, 电话号码, 国家, 省份, 城市, 区县等信息, 可以设置此地址是否为默认地址,
     * 通过 {@code Idempotency-Key} 请求头保证操作的幂等性</p>
     *
     * @param idempotencyKey 幂等键, 用于确保客户端多次发送相同的请求时服务器只处理一次, 防止重复创建
     * @param req            包含新地址详细信息的请求对象
     * @return 包含刚创建的地址信息的结果集, 如果成功创建, 返回状态码为 201 Created
     */
    @PostMapping
    public ResponseEntity<Result<AddressRespond>> create(@RequestHeader(value = "Idempotency-Key") String idempotencyKey,
                                                         @RequestBody @Valid CreateAddressRequest req) {
        req.validate();
        Long uid = requireCurrentUserId();

        PhoneNumber phoneNumber = PhoneNumber.of(req.getPhone());
        UserAddress newAddress = UserAddress.of(req.getReceiverName(), phoneNumber, req.getCountry(),
                req.getProvince(), req.getCity(), req.getDistrict(), req.getAddressLine1(), req.getAddressLine2(),
                req.getZipcode(), Boolean.TRUE.equals(req.getIsDefault()));

        UserAddress created = addressService.create(uid, newAddress, idempotencyKey);
        return ResponseEntity.status(ApiCode.CREATED.toHttpStatus())
                .body(Result.created(AddressRespond.from(created)));
    }

    /**
     * 根据指定的 ID 获取当前登录用户的单个收货地址信息
     *
     * @param id 收货地址的唯一标识符
     * @return 包含请求地址详细信息的结果集, 如果成功找到, 返回状态码为 200 OK
     */
    @GetMapping("/{id}")
    public ResponseEntity<Result<AddressRespond>> get(@PathVariable("id") Long id) {
        Long uid = requireCurrentUserId();
        UserAddress address = addressService.get(uid, id);
        return ResponseEntity.ok(Result.ok(AddressRespond.from(address)));
    }

    /**
     * 更新指定ID的收货地址信息
     *
     * <p>该方法允许用户更新已存在的收货地址, 包括接收者姓名, 电话号码, 国家, 省份, 城市, 区县等信息, 同时可以设置此地址是否为默认地址
     * 请求体中需包含 {@link UpdateAddressRequest} 对象, 用于传递新的地址详情</p>
     *
     * @param id  地址的唯一标识符
     * @param req 包含要更新的地址详细信息的请求对象
     * @return 包含更新后的地址信息的结果集, 如果成功更新, 返回状态码为 200 OK
     */
    @PatchMapping("/{id}")
    public ResponseEntity<Result<AddressRespond>> update(@PathVariable("id") Long id, @RequestBody UpdateAddressRequest req) {
        req.validate();
        Long uid = requireCurrentUserId();

        PhoneNumber phone = req.getPhone() == null ? null : PhoneNumber.nullableOf(req.getPhone());
        UserAddress updated = addressService.update(uid, id, req.getReceiverName(), phone, req.getCountry(),
                req.getProvince(), req.getCity(), req.getDistrict(), req.getAddressLine1(), req.getAddressLine2(),
                req.getZipcode(), req.getIsDefault());
        return ResponseEntity.ok(Result.ok(AddressRespond.from(updated), "地址已更新"));
    }

    /**
     * 删除指定ID的收货地址
     *
     * <p>此方法允许用户删除一个已存在的收货地址, 通过提供地址的唯一标识符 {@code id} 来执行删除操作, 删除后, 返回一个确认消息表示该地址已被成功删除</p>
     *
     * @param id 地址的唯一标识符, 用于定位要删除的具体地址
     * @return 包含删除结果的消息, 如果删除成功, 将返回状态码为 200 OK 的响应, 并携带确认消息 "地址已删除"
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Result<Void>> delete(@PathVariable("id") Long id) {
        Long uid = requireCurrentUserId();
        addressService.delete(uid, id);
        return ResponseEntity.ok(Result.ok("地址已删除"));
    }

    /**
     * 设置指定ID的地址为默认收货地址
     *
     * <p>此方法允许用户将一个已存在的收货地址设置为默认地址, 通过提供地址的唯一标识符 {@code id} 来执行设置操作,
     * 同一用户只能有一个默认地址, 如果之前已经存在默认地址, 则新的设置会覆盖旧的默认地址, </p>
     *
     * @param id 地址的唯一标识符, 用于定位要设置为默认的具体地址
     * @return 包含设置结果的消息, 如果成功设置, 将返回状态码为 200 OK 的响应, 并携带确认消息 "默认地址已设置"
     */
    @PostMapping("/{id}/set-default")
    public ResponseEntity<Result<Void>> setDefault(@PathVariable("id") Long id) {
        Long uid = requireCurrentUserId();
        addressService.setDefault(uid, id);
        return ResponseEntity.ok(Result.ok("默认地址已设置"));
    }

    /**
     * 从安全上下文中解析当前用户ID, 解析失败则抛出未登录异常
     *
     * @return 当前登录用户ID
     * @throws AccountException 如果用户未登录或无法解析当前用户信息时抛出
     */
    private Long requireCurrentUserId() {
        Authentication authentication = null;
        if (SecurityContextHolder.getContext() == null)
            authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !authentication.isAuthenticated())
            throw new AccountException("未登录");
        Object principal = authentication.getPrincipal();
        // 典型实现: principal 可为自定义对象, 需从中提取 id, 此处兼容 Long 和 Map-like 的简单示例
        if (principal instanceof Long longUserId)
            return longUserId;
        if (principal instanceof String stringUserId)
            return Long.parseLong(stringUserId);
        throw new AccountException("无法解析当前用户");
    }
}


// shopping.international.domain.service.user.IAddressService
package shopping.international.domain.service.user;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import shopping.international.domain.model.entity.user.UserAddress;
import shopping.international.domain.model.vo.user.PhoneNumber;
import shopping.international.types.exceptions.IllegalParamException;

import java.util.List;

/**
 * 收货地址领域服务接口
 */
public interface IAddressService {

    /**
     * 简单分页返回
     */
    record PageResult(List<UserAddress> items, long total) {
    }

    /**
     * 获取用户的收货地址列表, 使用默认分页参数
     *
     * @param userId 用户的唯一标识符, 用于筛选属于该用户的地址记录, 必须提供且非空
     * @return 返回一个 {@link PageResult} 对象, 包含了当前页的地址列表以及符合条件的地址总数, 默认情况下展示第一页, 每页5条记录
     */
    @NotNull
    default PageResult list(@NotNull Long userId) {
        return list(userId, 1, 5);
    }

    /**
     * 获取用户的收货地址列表, 使用默认分页参数, 每页展示5条记录
     *
     * @param userId 用户的唯一标识符, 用于筛选属于该用户的地址记录, 必须提供且非空
     * @param page   请求的页码, 从1开始计数, 用于分页逻辑中定位具体的页
     * @return 返回一个 {@link PageResult} 对象, 包含了当前页的地址列表以及符合条件的地址总数
     */
    @NotNull
    default PageResult list(@NotNull Long userId, int page) {
        return list(userId, page, 5);
    }

    /**
     * 获取用户的收货地址列表, 支持分页查询
     *
     * @param userId 用户的唯一标识符, 用于筛选属于该用户的地址记录, 必须提供且非空
     * @param page   请求的页码, 从1开始计数, 用于分页逻辑中定位具体的页
     * @param size   每页展示的地址条目数量, 用于控制单次请求返回的数据量
     * @return 返回一个 {@link PageResult} 对象, 包含了当前页的地址列表以及符合条件的地址总数
     */
    @NotNull
    PageResult list(@NotNull Long userId, int page, int size);


    /**
     * 根据用户ID和地址ID获取指定用户的特定收货地址信息
     *
     * @param userId    用户的唯一标识符, 用于筛选属于该用户的地址记录, 必须提供且非空
     * @param addressId 地址的唯一标识符, 用于定位具体的收货地址, 必须提供且非空
     * @return 返回一个 {@link UserAddress} 对象, 包含了指定地址的所有详细信息
     */
    @NotNull
    UserAddress get(@NotNull Long userId, @NotNull Long addressId);

    /**
     * 为指定用户创建一个新的收货地址
     *
     * @param userId         用户的唯一标识符, 用于关联新创建的地址到该用户, 必须提供且非空
     * @param address        包含了新地址详细信息的 {@link UserAddress} 对象, 必须提供且非空
     * @param idempotencyKey 用于确保请求幂等性的唯一键, 在重复请求时保证操作的一致性, 必须提供且非空
     * @return 返回一个新创建的 {@link UserAddress} 对象, 包括了系统生成的ID和其他详细信息
     */
    @NotNull
    UserAddress create(@NotNull Long userId, @NotNull UserAddress address, @NotNull String idempotencyKey);

    /**
     * 修改指定用户的收货地址信息
     *
     * @param userId       用户的唯一标识符, 用于筛选属于该用户的地址记录, 必须提供且非空
     * @param addressId    地址的唯一标识符, 用于定位具体的收货地址, 必须提供且非空
     * @param receiverName 收货人姓名, 可为空, 若不为空则更新该字段
     * @param phone        联系电话, 值对象, 可为空, 若不为空则更新该字段
     * @param country      国家, 可为空, 若不为空则更新该字段
     * @param province     省份, 可为空, 若不为空则更新该字段
     * @param city         城市, 可为空, 若不为空则更新该字段
     * @param district     区县, 可为空, 若不为空则更新该字段
     * @param addressLine1 地址行1, 可为空, 若不为空则更新该字段
     * @param addressLine2 地址行2, 可为空, 若不为空则更新该字段
     * @param zipcode      邮编, 可为空, 若不为空则更新该字段
     * @param makeDefault  是否设为默认地址, 可为空, 若不为空则根据其值设置当前地址是否为默认
     * @return 返回一个 {@link UserAddress} 对象, 包含了更新后的地址详细信息
     * @throws IllegalParamException 如果提供的 <code>receiverName</code> 或 <code>addressLine1</code> 为空白但不为 null 时抛出
     */
    @NotNull
    UserAddress update(@NotNull Long userId,
                       @NotNull Long addressId,
                       @Nullable String receiverName,
                       @Nullable PhoneNumber phone,
                       @Nullable String country,
                       @Nullable String province,
                       @Nullable String city,
                       @Nullable String district,
                       @Nullable String addressLine1,
                       @Nullable String addressLine2,
                       @Nullable String zipcode,
                       @Nullable Boolean makeDefault);

    /**
     * 删除指定用户的特定收货地址
     *
     * @param userId    用户的唯一标识符, 用于筛选属于该用户的地址记录, 必须提供且非空
     * @param addressId 地址的唯一标识符, 用于定位具体的收货地址, 必须提供且非空
     */
    void delete(@NotNull Long userId, @NotNull Long addressId);

    /**
     * 将指定用户的某个地址设为默认收货地址
     *
     * @param userId    用户的唯一标识符, 用于筛选属于该用户的地址记录, 必须提供且非空
     * @param addressId 地址的唯一标识符, 用于定位具体的收货地址, 必须提供且非空
     */
    void setDefault(@NotNull Long userId, @NotNull Long addressId);
}


// shopping.international.infrastructure.adapter.repository.user.UserRepository
package shopping.international.infrastructure.adapter.repository.user;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;
import shopping.international.domain.adapter.repository.user.IUserRepository;
import shopping.international.domain.model.aggregate.user.User;
import shopping.international.domain.model.entity.user.AuthBinding;
import shopping.international.domain.model.entity.user.UserAddress;
import shopping.international.domain.model.enums.user.AccountStatus;
import shopping.international.domain.model.enums.user.AuthProvider;
import shopping.international.domain.model.enums.user.Gender;
import shopping.international.domain.model.vo.user.*;
import shopping.international.infrastructure.dao.user.UserAccountMapper;
import shopping.international.infrastructure.dao.user.UserAddressMapper;
import shopping.international.infrastructure.dao.user.UserAuthMapper;
import shopping.international.infrastructure.dao.user.UserProfileMapper;
import shopping.international.infrastructure.dao.user.po.UserAccountPO;
import shopping.international.infrastructure.dao.user.po.UserAddressPO;
import shopping.international.infrastructure.dao.user.po.UserAuthPO;
import shopping.international.infrastructure.dao.user.po.UserProfilePO;
import shopping.international.types.exceptions.IllegalParamException;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static shopping.international.types.utils.FieldValidateUtils.requireNotBlank;

/**
 * 基于 MyBatis-Plus 的用户聚合仓储实现
 * <p>职责: 按聚合粒度对 {@code user_account / user_auth / user_profile / user_address} 进行组合读写</p>
 */
@Slf4j
@Repository
@RequiredArgsConstructor
public class UserRepository implements IUserRepository {

    /**
     * user_account Mapper
     */
    private final UserAccountMapper accountMapper;
    /**
     * user_auth Mapper
     */
    private final UserAuthMapper authMapper;
    /**
     * user_profile Mapper
     */
    private final UserProfileMapper profileMapper;
    /**
     * user_address Mapper
     */
    private final UserAddressMapper addressMapper;
    /**
     * JSON 序列化/反序列化工具
     */
    private final ObjectMapper mapper;

    // ========================= 查询 =========================

    /**
     * 按登录账号查询用户 (账号为用户名 / 邮箱 / 手机号), 返回完整聚合快照 (含绑定)
     *
     * @param account 用户名 / 邮箱 / 手机号
     * @return 用户聚合, 可为空
     */
    @Override
    public Optional<User> findByLoginAccount(@NotNull String account) {
        UserAccountPO po = accountMapper.selectOne(new LambdaQueryWrapper<UserAccountPO>()
                .eq(UserAccountPO::getUsername, account)
                .or(wrapper -> wrapper.eq(UserAccountPO::getEmail, account))
                .or(wrapper -> wrapper.eq(UserAccountPO::getPhone, account))
                .eq(UserAccountPO::getIsDeleted, Boolean.FALSE)
                .last("limit 1"));
        return assembleOptional(po);
    }

    /**
     * 按邮箱精确查询用户 (用于激活等流程), 返回完整聚合快照
     *
     * @param email 邮箱
     * @return 用户聚合, 可为空
     */
    @Override
    public Optional<User> findByEmail(@NotNull EmailAddress email) {
        UserAccountPO po = accountMapper.selectOne(new LambdaQueryWrapper<UserAccountPO>()
                .eq(UserAccountPO::getEmail, email.getValue())
                .eq(UserAccountPO::getIsDeleted, Boolean.FALSE)
                .last("limit 1"));
        return assembleOptional(po);
    }

    /**
     * 按主键查询用户
     *
     * @param userId 用户 ID
     * @return 用户聚合, 可为空
     */
    @Override
    public Optional<User> findById(@NotNull Long userId) {
        UserAccountPO po = accountMapper.selectById(userId);
        if (po == null || Boolean.TRUE.equals(po.getIsDeleted()))
            return Optional.empty();
        return assembleOptional(po);
    }

    /**
     * 检查用户名是否已存在 (幂等注册前置唯一性校验)
     *
     * @param username 用户名
     * @return 是否存在
     */
    @Override
    public boolean existsByUsername(@NotNull Username username) {
        Long n = accountMapper.selectCount(new LambdaQueryWrapper<UserAccountPO>()
                .eq(UserAccountPO::getUsername, username.getValue())
                .eq(UserAccountPO::getIsDeleted, Boolean.FALSE));
        return n != null && n > 0;
    }

    /**
     * 检查邮箱是否已存在 (幂等注册前置唯一性校验)
     *
     * @param email 邮箱
     * @return 是否存在 (忽略 null)
     */
    @Override
    public boolean existsByEmail(@NotNull EmailAddress email) {
        Long n = accountMapper.selectCount(new LambdaQueryWrapper<UserAccountPO>()
                .eq(UserAccountPO::getEmail, email.getValue())
                .eq(UserAccountPO::getIsDeleted, Boolean.FALSE));
        return n != null && n > 0;
    }

    /**
     * 检查手机号是否已存在 (幂等注册前置唯一性校验)
     *
     * @param phone 手机号
     * @return 是否存在 (忽略 null)
     */
    @Override
    public boolean existsByPhone(@NotNull PhoneNumber phone) {
        Long n = accountMapper.selectCount(new LambdaQueryWrapper<UserAccountPO>()
                .eq(UserAccountPO::getPhone, phone.getValue())
                .eq(UserAccountPO::getIsDeleted, Boolean.FALSE));
        return n != null && n > 0;
    }

    /**
     * 按第三方身份 (issuer + provider_uid/sub) 查询用户
     *
     * @param issuer      OIDC iss (或等价发行方标识)
     * @param providerUid OIDC sub (发行方内用户唯一 ID)
     * @return 用户聚合
     */
    @Override
    public @NotNull Optional<User> findByProviderUid(@NotNull String issuer, @NotNull String providerUid) {
        UserAuthPO auth = authMapper.selectOne(new LambdaQueryWrapper<UserAuthPO>()
                .eq(UserAuthPO::getIssuer, issuer)
                .eq(UserAuthPO::getProviderUid, providerUid)
                .last("limit 1"));
        if (auth == null)
            return Optional.empty();
        UserAccountPO account = accountMapper.selectById(auth.getUserId());
        if (account == null || Boolean.TRUE.equals(account.getIsDeleted()))
            return Optional.empty();
        return assembleOptional(account);
    }

    // ========================= 写入 =========================

    /**
     * 持久化一个全新的用户聚合 (账户 + 绑定 + 资料 + 地址)
     *
     * <p>要求 {@code user.id == null}, 至少存在一种登录方式
     * 若存在 LOCAL 绑定, 则其 passwordHash 必须非空
     * 成功后返回带持久化主键的快照 (含各子实体主键)</p>
     *
     * @param user 待保存的新用户对象, 包含用户账户, 绑定信息, 资料及地址等
     * @return 保存后的用户对象, 包括由数据库生成的主键和其他相关字段
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public @NotNull User saveNewUserWithBindings(User user) {
        // 1. 入库 user_account
        requireNotBlank(user.getEmail().getValue(), "用户邮箱不能为空");
        UserAccountPO acc = UserAccountPO.builder()
                .username(user.getUsername().getValue())
                .nickname(user.getNickname().getValue())
                .email(user.getEmail().getValue())
                .phone(user.getPhone() == null ? null : user.getPhone().getValue())
                .status(user.getStatus() == null ? AccountStatus.DISABLED.name() : user.getStatus().name())
                .lastLoginAt(user.getLastLoginAt())
                .isDeleted(Boolean.FALSE)
                .build();
        accountMapper.insert(acc); // 自增主键回填
        Long userId = acc.getId();

        // 2. 入库 user_profile
        UserProfilePO profile = new UserProfilePO(
                userId,
                user.getProfile() == null ? null : user.getProfile().getDisplayName(),
                user.getProfile() == null ? null : user.getProfile().getAvatarUrl(),
                user.getProfile() == null ? Gender.UNKNOWN.name() : user.getProfile().getGender().name(),   // Gender → String
                user.getProfile() == null ? null : user.getProfile().getBirthday(),
                user.getProfile() == null ? null : user.getProfile().getCountry(),
                user.getProfile() == null ? null : user.getProfile().getProvince(),
                user.getProfile() == null ? null : user.getProfile().getCity(),
                user.getProfile() == null ? null : user.getProfile().getAddressLine(),
                user.getProfile() == null ? null : user.getProfile().getZipcode(),
                user.getProfile() == null ? null : toJsonOrNull(user.getProfile().getExtra()), // Map → JSON
                java.time.LocalDateTime.now(),
                java.time.LocalDateTime.now()
        );
        profileMapper.insert(profile);

        // 3. 入库 user_auth (遍历绑定)
        for (AuthBinding binding : user.getBindingsSnapshot()) {
            UserAuthPO authPO = UserAuthPO.builder()
                    .userId(userId)
                    .provider(binding.getProvider().name())
                    .issuer(binding.getIssuer())
                    .providerUid(binding.getProvider() == AuthProvider.LOCAL ? userId.toString() : binding.getProviderUid())
                    .passwordHash(binding.getPasswordHash())
                    .accessToken(binding.getAccessToken() == null ? null : binding.getAccessToken().getBytes())   // EncryptedSecret → bytes()
                    .refreshToken(binding.getRefreshToken() == null ? null : binding.getRefreshToken().getBytes())
                    .expiresAt(binding.getExpiresAt())
                    .scope(binding.getScope())
                    .role(binding.getRole())
                    .lastLoginAt(binding.getLastLoginAt())
                    .build();
            authMapper.insert(authPO);
        }

        // 4 入库 user_address
        if (user.getAddressesSnapshot() != null && !user.getAddressesSnapshot().isEmpty()) {
            for (UserAddress a : user.getAddressesSnapshot()) {
                UserAddressPO addressPO = UserAddressPO.builder()
                        .userId(userId)
                        .receiverName(a.getReceiverName())
                        .phone(a.getPhone() == null ? null : a.getPhone().getValue())
                        .country(a.getCountry())
                        .province(a.getProvince())
                        .city(a.getCity())
                        .district(a.getDistrict())
                        .addressLine1(a.getAddressLine1())
                        .addressLine2(a.getAddressLine2())
                        .zipcode(a.getZipcode())
                        .isDefault(a.isDefaultAddress())
                        .build();
                addressMapper.insert(addressPO);
            }
        }

        // 5. 回读聚合 (含各子表主键)
        return findById(userId).orElseThrow(() -> new IllegalStateException("保存后回读用户失败"));
    }

    /**
     * 更新账户状态 (如 DISABLED → ACTIVE)
     *
     * @param userId 用户 ID
     * @param status 新状态
     */
    @Override
    public void updateStatus(@NotNull Long userId, @NotNull AccountStatus status) {
        accountMapper.update(null, new LambdaUpdateWrapper<UserAccountPO>()
                .eq(UserAccountPO::getId, userId)
                .set(UserAccountPO::getStatus, status.name()));
    }

    /**
     * 记录登录时间戳与通道最近登录时间 (如 provider=LOCAL)
     *
     * @param userId    用户 ID
     * @param provider  认证提供方
     * @param loginTime 登录时间
     */
    @Override
    public void recordLogin(@NotNull Long userId, @NotNull AuthProvider provider, @NotNull LocalDateTime loginTime) {
        // 1) 更新账户最近登录
        accountMapper.update(null, new LambdaUpdateWrapper<UserAccountPO>()
                .eq(UserAccountPO::getId, userId)
                .set(UserAccountPO::getLastLoginAt, loginTime));
        // 2) 更新对应通道最近登录
        authMapper.update(null, new LambdaUpdateWrapper<UserAuthPO>()
                .eq(UserAuthPO::getUserId, userId)
                .eq(UserAuthPO::getProvider, provider.name())
                .set(UserAuthPO::getLastLoginAt, loginTime));
    }

    // ========================= 增量写入 =========================

    /**
     * 检查是否存在手机号相同的其他用户, 排除指定的用户 ID
     *
     * @param userId 用户 ID 需要排除的用户 ID, 用于避免查询到当前用户自己
     * @param phone  手机号 要检查的手机号, 必须是有效的 {@link PhoneNumber} 对象
     * @return 是否存在 如果存在其他用户的手机号与给定的手机号相同, 返回 true; 否则返回 false
     */
    @Override
    public boolean existsByPhoneExceptUser(@NotNull Long userId, @NotNull PhoneNumber phone) {
        Long count = accountMapper.selectCount(new LambdaQueryWrapper<UserAccountPO>()
                .eq(UserAccountPO::getPhone, phone.getValue())
                .eq(UserAccountPO::getIsDeleted, Boolean.FALSE)
                .ne(UserAccountPO::getId, userId));
        return count != null && count > 0;
    }


    /**
     * 更新指定用户ID的昵称和手机号
     *
     * @param userId   用户ID, 必须提供
     * @param nickname 新的昵称, 可以是 {@code null}, 如果为 {@code null} 则不更新昵称
     * @param phone    新的手机号, 可以是 {@code null}, 如果为 {@code null} 则不更新手机号
     * @throws IllegalStateException 当尝试更新不存在或已删除的用户时抛出
     */
    @Override
    public void updateNicknameAndPhone(@NotNull Long userId, @Nullable Nickname nickname, @Nullable PhoneNumber phone) {
        LambdaUpdateWrapper<UserAccountPO> updateWrapper = new LambdaUpdateWrapper<UserAccountPO>()
                .eq(UserAccountPO::getId, userId)
                .eq(UserAccountPO::getIsDeleted, Boolean.FALSE);

        boolean needUpdate = false;
        if (nickname != null) {
            updateWrapper.set(UserAccountPO::getNickname, nickname.getValue());
            needUpdate = true;
        }
        if (phone != null) {
            updateWrapper.set(UserAccountPO::getPhone, phone.getValue());
            needUpdate = true;
        }
        if (!needUpdate)
            // 无字段需要更新, 直接返回
            return;

        int rows = accountMapper.update(null, updateWrapper);
        if (rows == 0)
            throw new IllegalStateException("更新失败, 用户不存在或已删除");
    }


    /**
     * 更新指定用户的邮箱地址
     *
     * @param userId   用户ID, 必须提供
     * @param newEmail 新的邮箱地址, 必须提供
     * @throws IllegalStateException 当尝试更新不存在或已删除的用户时抛出
     */
    @Override
    public void updateEmail(@NotNull Long userId, @NotNull EmailAddress newEmail) {
        int rows;
        try {
            rows = accountMapper.update(null, new LambdaUpdateWrapper<UserAccountPO>()
                    .eq(UserAccountPO::getId, userId)
                    .eq(UserAccountPO::getIsDeleted, Boolean.FALSE)
                    .set(UserAccountPO::getEmail, newEmail.getValue()));
        } catch (DataIntegrityViolationException ex) {
            // 与并发竞争或唯一约束冲突对齐
            throw new IllegalParamException("邮箱已被使用");
        }
        if (rows == 0)
            throw new IllegalStateException("更新失败: 用户不存在或已删除");
    }


    /**
     * 插入或更新用户资料信息. 如果指定的用户ID不存在, 则插入新的用户资料, 如果存在, 则更新现有资料
     *
     * @param userId  用户ID, 用于识别用户
     * @param profile 用户资料对象, 包含了用户的显示名称, 头像URL, 性别, 生日, 国家, 省份, 城市, 地址行, 邮政编码以及额外信息等
     * @throws IllegalArgumentException 如果传入的参数不符合要求 (例如, userId 为 null, 或者 profile 为 null)
     */
    @Override
    public void upsertProfile(@NotNull Long userId, @NotNull UserProfile profile) {
        // 先取一次, 判断是否存在
        UserProfilePO existed = profileMapper.selectById(userId);

        String gender = profile.getGender().name();
        if (existed == null) {
            // 插入
            UserProfilePO toInsert = new UserProfilePO(
                    userId,
                    profile.getDisplayName(),
                    profile.getAvatarUrl(),
                    gender,
                    profile.getBirthday(),
                    profile.getCountry(),
                    profile.getProvince(),
                    profile.getCity(),
                    profile.getAddressLine(),
                    profile.getZipcode(),
                    toJsonOrNull(profile.getExtra()),
                    null, // created_at 交由数据库默认
                    null  // updated_at 交由数据库默认
            );
            profileMapper.insert(toInsert);
        } else {
            // 更新 (仅设置可变字段, created_at/updated_at 交由 DB 维护)
            profileMapper.update(null, new LambdaUpdateWrapper<UserProfilePO>()
                    .eq(UserProfilePO::userId, userId)
                    .set(UserProfilePO::displayName, profile.getDisplayName())
                    .set(UserProfilePO::avatarUrl, profile.getAvatarUrl())
                    .set(UserProfilePO::gender, gender)
                    .set(UserProfilePO::birthday, profile.getBirthday())
                    .set(UserProfilePO::country, profile.getCountry())
                    .set(UserProfilePO::province, profile.getProvince())
                    .set(UserProfilePO::city, profile.getCity())
                    .set(UserProfilePO::addressLine, profile.getAddressLine())
                    .set(UserProfilePO::zipcode, profile.getZipcode())
                    .set(UserProfilePO::extra, toJsonOrNull(profile.getExtra()))
            );
        }
    }

    // ========================= 授权绑定 =========================

    /**
     * 根据用户 ID 列出所有绑定的授权信息
     *
     * @param userId 用户 ID, 用于查询特定用户的授权绑定信息
     * @return 返回一个包含 {@link AuthBinding} 对象的列表, 每个对象代表一条授权绑定记录
     */
    @Override
    public @NotNull List<AuthBinding> listBindingsByUserId(@NotNull Long userId) {
        List<UserAuthPO> list = authMapper.selectList(new LambdaQueryWrapper<UserAuthPO>()
                .eq(UserAuthPO::getUserId, userId)
                .orderByAsc(UserAuthPO::getId));
        return list.stream().map(this::toDomainAuth).toList();
    }

    /**
     * 检查是否存在由特定 issuer 和 providerUid 定义的身份验证绑定, 并且该绑定不属于指定的用户
     *
     * @param issuer        发行者标识符 不能为 null
     * @param providerUid   提供者的唯一标识符 不能为 null
     * @param excludeUserId 需要排除的用户 ID, 即检查时会忽略该用户的绑定 不能为 null
     * @return 如果存在符合条件的绑定则返回 true, 否则返回 false
     */
    @Override
    public boolean existsBindingByIssuerAndUidExcludingUser(@NotNull String issuer, @NotNull String providerUid,
                                                            @NotNull Long excludeUserId) {
        UserAuthPO po = authMapper.selectOne(new LambdaQueryWrapper<UserAuthPO>()
                .eq(UserAuthPO::getIssuer, issuer)
                .eq(UserAuthPO::getProviderUid, providerUid)
                .last("limit 1"));
        if (po == null)
            return false;
        return !excludeUserId.equals(po.getUserId());
    }

    /**
     * 计算指定用户 <code>userId</code> 的绑定记录数量
     *
     * @param userId 用户的唯一标识符 不能为 null
     * @return 绑定记录的数量 如果
     */
    @Override
    public int countBindings(@NotNull Long userId) {
        Long rows = authMapper.selectCount(new LambdaQueryWrapper<UserAuthPO>()
                .eq(UserAuthPO::getUserId, userId));
        return rows == null ? 0 : rows.intValue();
    }

    /**
     * <p>插入或更新用户的授权绑定信息, 如果用户对于指定的提供商已经存在授权绑定, 则更新该绑定, 否则, 插入新的授权绑定</p>
     *
     * @param userId  用户ID 必填
     * @param binding 授权绑定信息, 包含提供商(provider), 发行者(issuer), 提供商唯一标识(providerUid), 访问令牌(accessToken), 刷新令牌(refreshToken), 过期时间(expiresAt)和权限范围(scope)等 必填
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void upsertAuthBinding(@NotNull Long userId, @NotNull AuthBinding binding) {
        AuthProvider provider = binding.getProvider();
        String issuer = binding.getIssuer();
        String providerUid = binding.getProviderUid();
        EncryptedSecret accessToken = binding.getAccessToken();
        EncryptedSecret refreshToken = binding.getRefreshToken();
        LocalDateTime expiresAt = binding.getExpiresAt();
        String scope = binding.getScope();

        UserAuthPO existed = authMapper.selectOne(new LambdaQueryWrapper<UserAuthPO>()
                .eq(UserAuthPO::getUserId, userId)
                .eq(UserAuthPO::getProvider, provider.name())
                .last("limit 1"));

        LocalDateTime now = LocalDateTime.now();

        if (existed == null) {
            UserAuthPO toInsert = UserAuthPO.builder()
                    .userId(userId)
                    .provider(provider.name())
                    .issuer(issuer)
                    .providerUid(providerUid)
                    .passwordHash(null)
                    .accessToken(accessToken == null ? null : accessToken.getBytes())
                    .refreshToken(refreshToken == null ? null : refreshToken.getBytes())
                    .expiresAt(expiresAt)
                    .scope(scope)
                    .role(null)
                    .lastLoginAt(now)
                    .build();
            authMapper.insert(toInsert);
        } else {
            authMapper.update(null, new LambdaUpdateWrapper<UserAuthPO>()
                    .eq(UserAuthPO::getId, existed.getId())
                    .set(UserAuthPO::getIssuer, issuer)
                    .set(UserAuthPO::getProviderUid, providerUid)
                    .set(UserAuthPO::getAccessToken, accessToken == null ? null : accessToken.getBytes())
                    .set(UserAuthPO::getRefreshToken, refreshToken == null ? null : refreshToken.getBytes())
                    .set(UserAuthPO::getExpiresAt, expiresAt)
                    .set(UserAuthPO::getScope, scope)
                    .set(UserAuthPO::getLastLoginAt, now));
        }
    }

    /**
     * 删除指定用户与特定身份验证提供者之间的绑定关系
     *
     * @param userId   用户的唯一标识符, 不能为空
     * @param provider 身份验证提供者的枚举值, 不能为空
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void deleteBinding(@NotNull Long userId, @NotNull AuthProvider provider) {
        authMapper.delete(new LambdaQueryWrapper<UserAuthPO>()
                .eq(UserAuthPO::getUserId, userId)
                .eq(UserAuthPO::getProvider, provider.name()));
    }

    // ========================= 装配工具 =========================

    /**
     * 根据给定的用户账户持久化对象 <code>UserAccountPO</code>, 组装并返回一个完整的 <code>User</code> 对象封装在 <code>Optional</code> 中
     * 如果传入的 <code>UserAccountPO</code> 为 null, 则直接返回 <code>Optional.empty()</code>
     *
     * @param account 用户账户持久化对象, 包含用户的基本信息
     * @return 封装了完整用户信息 (包括但不限于基本资料, 认证绑定, 地址等) 的 <code>Optional<User></code> 实例,
     * 若无法组装或输入为空, 则返回 <code>Optional.empty()</code>
     */
    private Optional<User> assembleOptional(UserAccountPO account) {
        if (account == null)
            return Optional.empty();

        // 子表装载
        List<UserAuthPO> authList = authMapper.selectList(new LambdaQueryWrapper<UserAuthPO>()
                .eq(UserAuthPO::getUserId, account.getId()));
        List<UserAddressPO> addrList = addressMapper.selectList(new LambdaQueryWrapper<UserAddressPO>()
                .eq(UserAddressPO::getUserId, account.getId()));
        UserProfilePO profile = profileMapper.selectById(account.getId());

        // 映射子实体
        List<AuthBinding> bindings = authList.stream().map(this::toDomainAuth).toList();
        List<UserAddress> addresses = addrList.stream().map(this::toDomainAddress).toList();

        // Profile → 值对象 (你的 UserProfile API 若不同, 可在此适配)
        UserProfile profileVO = (profile == null) ? UserProfile.empty() : UserProfile.of(
                profile.displayName(),
                profile.avatarUrl(),
                parseGender(profile.gender()),
                profile.birthday(),
                profile.country(),
                profile.province(),
                profile.city(),
                profile.addressLine(),
                profile.zipcode(),
                parseJsonToMap(profile.extra())
        );

        requireNotBlank(account.getEmail(), "用户邮箱不能为空");
        // 还原聚合
        User user = User.reconstitute(
                account.getId(),
                Username.of(account.getUsername()),
                Nickname.of(account.getNickname()),
                EmailAddress.of(account.getEmail()),
                account.getPhone() == null ? null : PhoneNumber.nullableOf(account.getPhone()),
                AccountStatus.valueOf(account.getStatus()),
                account.getLastLoginAt(),
                Boolean.TRUE.equals(account.getIsDeleted()),
                account.getCreatedAt(),
                account.getUpdatedAt(),
                profileVO,
                bindings,
                addresses
        );
        return Optional.of(user);
    }

    /**
     * 将用户认证持久化对象转换为领域模型中的认证绑定实体
     *
     * @param authPO 用户认证持久化对象, 包含了用户认证所需的所有信息, 如提供商, 访问令牌等
     * @return 转换后的认证绑定实体, 代表了用户的某一种认证方式的详细信息
     */
    private AuthBinding toDomainAuth(UserAuthPO authPO) {
        return new AuthBinding(
                authPO.getId(),
                AuthProvider.valueOf(authPO.getProvider()),
                authPO.getIssuer(),
                authPO.getProviderUid(),
                authPO.getPasswordHash(),
                authPO.getAccessToken() == null ? null : EncryptedSecret.of(authPO.getAccessToken()),
                authPO.getRefreshToken() == null ? null : EncryptedSecret.of(authPO.getRefreshToken()),
                authPO.getExpiresAt(),
                authPO.getScope(),
                authPO.getRole(),
                authPO.getLastLoginAt(),
                authPO.getCreatedAt(),
                authPO.getUpdatedAt()
        );
    }

    /**
     * 将用户地址持久化对象转换为领域模型中的用户地址实体
     *
     * @param addressPO 用户地址持久化对象, 包含了用户地址的所有信息
     * @return 转换后的 {@link UserAddress} 实体, 代表用户的某个收货地址的详细信息
     */
    private UserAddress toDomainAddress(UserAddressPO addressPO) {
        return new UserAddress(
                addressPO.getId(),
                addressPO.getReceiverName(),
                addressPO.getPhone() == null ? null : PhoneNumber.nullableOf(addressPO.getPhone()),
                addressPO.getCountry(),
                addressPO.getProvince(),
                addressPO.getCity(),
                addressPO.getDistrict(),
                addressPO.getAddressLine1(),
                addressPO.getAddressLine2(),
                addressPO.getZipcode(),
                Boolean.TRUE.equals(addressPO.getIsDefault()),
                addressPO.getCreatedAt(),
                addressPO.getUpdatedAt()
        );
    }

    /**
     * 将原始字符串解析为性别枚举值
     *
     * @param raw 原始字符串, 代表性别的英文表示, 如 "MALE", "FEMALE" 或 "UNKNOWN"
     * @return 解析后的 {@link Gender} 枚举值, 如果输入为空或无法匹配任何已定义的枚举, 则返回 {@link Gender#UNKNOWN UNKNOWN}
     */
    private static Gender parseGender(String raw) {
        if (raw == null || raw.isBlank())
            return Gender.UNKNOWN;
        try {
            return Gender.valueOf(raw.toUpperCase());
        } catch (IllegalArgumentException ex) {
            return Gender.UNKNOWN;
        }
    }

    /**
     * 将 JSON 字符串解析为键值对映射
     *
     * @param json 待解析的 JSON 字符串, 可以是任何有效的 JSON 格式字符串, 如果为空或空白, 则返回空映射
     * @return 解析后的键值对映射, 其中键为字符串, 值可以是任意类型, 如果解析失败, 也返回空映射
     */
    private Map<String, Object> parseJsonToMap(String json) {
        if (json == null || json.isBlank())
            return Map.of();
        try {
            return mapper.readValue(json, new TypeReference<>() {
            });
        } catch (Exception e) {
            log.error("解析 JSON 字符串失败: {}", e.getMessage());
            return Map.of();
        }
    }

    /**
     * 将给定的键值对映射转换为 JSON 字符串, 如果映射为空或转换过程中发生异常, 则返回 null.
     *
     * @param map 待转换的键值对映射, 其中键为字符串类型, 值可以是任意对象. 如果 <code>map</code> 为 null 或空, 方法将直接返回 null.
     * @return 转换后的 JSON 字符串, 如果输入映射为空, 或在转换过程中遇到任何异常, 则返回 null.
     */
    private String toJsonOrNull(java.util.Map<String, Object> map) {
        if (map == null || map.isEmpty())
            return null;
        try {
            return mapper.writeValueAsString(map);
        } catch (Exception e) {
            // 失败时可以选择返回 null 或抛出受检异常, 这里回退为 null
            log.error("转换 JSON 字符串失败: {}", e.getMessage());
            return null;
        }
    }
}


// shopping.international.infrastructure.dao.user.po.UserAccountPO
package shopping.international.infrastructure.dao.user.po;

import com.baomidou.mybatisplus.annotation.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * 持久化对象: user_account
 * <p>映射用户账户主表 (JWT 认证), 用于 MyBatis-Plus CRUD</p>
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@TableName("user_account")
public class UserAccountPO {
    /**
     * 主键ID (自增)
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Long id;
    /**
     * 用户名(登录名)
     */
    @TableField("username")
    private String username;
    /**
     * 昵称/显示名
     */
    @TableField("nickname")
    private String nickname;
    /**
     * 邮箱
     */
    @TableField("email")
    private String email;
    /**
     * 手机号
     */
    @TableField("phone")
    private String phone;
    /**
     * 账户状态 (ACTIVE/DISABLED)
     */
    @TableField("status")
    private String status;
    /**
     * 最近登录时间
     */
    @TableField("last_login_at")
    private LocalDateTime lastLoginAt;
    /**
     * 软删除标记(0/1)
     */
    @TableField("is_deleted")
    private Boolean isDeleted;
    /**
     * 创建时间
     */
    @TableField(value = "created_at", insertStrategy = FieldStrategy.NEVER, updateStrategy = FieldStrategy.NEVER)
    private LocalDateTime createdAt;
    /**
     * 更新时间
     */
    @TableField(value = "updated_at", insertStrategy = FieldStrategy.NEVER, updateStrategy = FieldStrategy.NEVER)
    private LocalDateTime updatedAt;
}

// shopping.international.infrastructure.dao.user.po.UserAddressPO
package shopping.international.infrastructure.dao.user.po;

import com.baomidou.mybatisplus.annotation.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * 持久化对象: user_address
 * <p>用户收货地址 1:N</p>
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@TableName("user_address")
public class UserAddressPO {
    /**
     * 主键ID (自增)
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Long id;
    /**
     * 用户ID
     */
    @TableField("user_id")
    private Long userId;
    /**
     * 收货人
     */
    @TableField("receiver_name")
    private String receiverName;
    /**
     * 联系电话 (字符串持久化)
     */
    @TableField("phone")
    private String phone;
    /**
     * 国家
     */
    @TableField("country")
    private String country;
    /**
     * 省/州
     */
    @TableField("province")
    private String province;
    /**
     * 城市
     */
    @TableField("city")
    private String city;
    /**
     * 区/县
     */
    @TableField("district")
    private String district;
    /**
     * 地址行1
     */
    @TableField("address_line1")
    private String addressLine1;
    /**
     * 地址行2
     */
    @TableField("address_line2")
    private String addressLine2;
    /**
     * 邮编
     */
    @TableField("zipcode")
    private String zipcode;
    /**
     * 是否默认地址
     */
    @TableField("is_default")
    private Boolean isDefault;
    /**
     * 创建时间
     */
    @TableField(value = "created_at", insertStrategy = FieldStrategy.NEVER, updateStrategy = FieldStrategy.NEVER)
    private LocalDateTime createdAt;
    /**
     * 更新时间
     */
    @TableField(value = "updated_at", insertStrategy = FieldStrategy.NEVER, updateStrategy = FieldStrategy.NEVER)
    private LocalDateTime updatedAt;
}

// shopping.international.infrastructure.dao.user.po.UserAuthPO
package shopping.international.infrastructure.dao.user.po;

import com.baomidou.mybatisplus.annotation.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * 持久化对象: user_auth
 * <p>映射用户认证绑定 (本地/OAuth2)</p>
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@TableName("user_auth")
public class UserAuthPO {
    /**
     * 主键ID (自增)
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Long id;
    /**
     * 用户ID
     */
    @TableField("user_id")
    private Long userId;
    /**
     * 提供方 (LOCAL/GOOGLE/...)
     */
    @TableField("provider")
    private String provider;
    /**
     * 发行方 (OIDC iss)
     */
    @TableField("issuer")
    private String issuer;
    /**
     * 发行方内唯一ID (OIDC sub)
     */
    @TableField("provider_uid")
    private String providerUid;
    /**
     * 本地密码哈希 (仅 LOCAL)
     */
    @TableField("password_hash")
    private String passwordHash;
    /**
     * 访问令牌 (加密后字节)
     */
    @TableField("access_token")
    private byte[] accessToken;
    /**
     * 刷新令牌 (加密后字节)
     */
    @TableField("refresh_token")
    private byte[] refreshToken;
    /**
     * 访问令牌过期时间
     */
    @TableField("expires_at")
    private LocalDateTime expiresAt;
    /**
     * 授权范围 (逗号或空格分隔)
     */
    @TableField("scope")
    private String scope;
    /**
     * 角色
     */
    @TableField("role")
    private String role;
    /**
     * 该通道最近登录时间
     */
    @TableField("last_login_at")
    private LocalDateTime lastLoginAt;
    /**
     * 创建时间
     */
    @TableField(value = "created_at", insertStrategy = FieldStrategy.NEVER, updateStrategy = FieldStrategy.NEVER)
    private LocalDateTime createdAt;
    /**
     * 更新时间
     */
    @TableField(value = "updated_at", insertStrategy = FieldStrategy.NEVER, updateStrategy = FieldStrategy.NEVER)
    private LocalDateTime updatedAt;
}

// shopping.international.infrastructure.dao.user.po.UserProfilePO
package shopping.international.infrastructure.dao.user.po;

import com.baomidou.mybatisplus.annotation.FieldStrategy;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import java.time.LocalDate;
import java.time.LocalDateTime;

/**
 * 持久化对象：user_profile (record)
 * <p>用户资料 1:1；主键为 user_id, 非自增</p>
 *
 * <ol>
 *     <li>{@code userId: }用户ID (主键) </li>
 *     <li>{@code displayName: }显示名</li>
 *     <li>{@code avatarUrl: }头像URL</li>
 *     <li>{@code gender: }性别 (UNKNOWN/MALE/FEMALE) </li>
 *     <li>{@code birthday: }生日</li>
 *     <li>{@code country: }国家</li>
 *     <li>{@code province: }省/州</li>
 *     <li>{@code city: }城市</li>
 *     <li>{@code addressLine: }地址(简单场景)</li>
 *     <li>{@code zipcode: }邮编</li>
 *     <li>{@code extra: }扩展信息(JSON)</li>
 *     <li>{@code createdAt: }创建时间</li>
 *     <li>{@code updatedAt: }更新时间</li>
 * </ol>
 *
 * <p>注意：record 字段不可回填主键, 自增不适用；本表符合 record 的不可变场景</p>
 *
 */
@TableName("user_profile")
public record UserProfilePO(
        @TableId("user_id") Long userId,
        @TableField("display_name") String displayName,
        @TableField("avatar_url") String avatarUrl,
        @TableField("gender") String gender,
        @TableField("birthday") LocalDate birthday,
        @TableField("country") String country,
        @TableField("province") String province,
        @TableField("city") String city,
        @TableField("address_line") String addressLine,
        @TableField("zipcode") String zipcode,
        @TableField("extra") String extra,
        @TableField(value = "created_at", insertStrategy = FieldStrategy.NEVER, updateStrategy = FieldStrategy.NEVER)
        LocalDateTime createdAt,
        @TableField(value = "updated_at", insertStrategy = FieldStrategy.NEVER, updateStrategy = FieldStrategy.NEVER)
        LocalDateTime updatedAt
) {
}

